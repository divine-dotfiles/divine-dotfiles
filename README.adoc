= Divine.dotfiles
:author: Grove Pyree
:email: grayarea@protonmail.ch
:revnumber: 25
:revdate: 2019.08.16
:revremark: Iterative improvement
:doctype: article
// Visual
:toc:
// Subs:
:hs: #
:dhs: ##

++++
<p align="center">
<em>Bash framework for dotfiles and everything Bash</em>
</p>
++++

[#divine-dotfiles-plaque]
image::lib/img/divine-dotfiles-plaque.png[Divine.dotfiles,align="center"]

New machine or new OS?
Set it up with a single `*di install --yes*`.

[NOTE]
--
`di` stands for **d**ivine **i**ntervention.
--

_Divine.dotfiles_ lets you keep your set-up routines as isolated _deployments_ that are installed/removed in defined sequence.

== In a nutshell

_Divine.dotfiles_ leverages *deployments*.

A deployment is a Bash script with three specially named functions: one to check, another to install, third to remove.
Return codes are used to communicate back to the framework.
As such, authoring a deployment is akin to implementing an interface.

The goal of _Divine.dotfiles_ is *portability* and *cross-platformness* within Unix-like world.
Deployment ecosystem is designed for distribution and pluggability.
A well put together collection of deployments is able to:

* Streamline and simplify seting up new machines.
* Promote standards and best practices.

=== Example deployment

Say, you install the same command line utility on every machine.
Here's a sample deployment that does a scaled down version of that:

[source,bash,subs="verbatim,attributes"]
----
# grail/dpls/example.dpl.sh

d_dpl_check() {
  [ -e ~/bin/cmd ] && return 1 {vbar}{vbar} return 2
}

d_dpl_install() {
  cat >~/bin/cmd <<<'echo Divine.dotfiles rocks' && chmod +x ~/bin/cmd
}

d_dpl_remove() {
  rm -f -- ~/bin/cmd
}
----

And here is what working with it looks like:

[#divine-dotfiles-example-1]
image::lib/img/divine-dotfiles-example-1.gif[Divine.dotfiles example 1,align="center"]

Dead simple, right?
You wouldn’t need a framework for that.
But wait, there’s [.small]#_(hopefully)_# more.

=== Framework features

[header,cols="<.^1,<.^4",stripes=none]
|===

| *Divinefile*
| Special deployment that maintains a stable set of system packages across machines and OS's

| *Grail directory*
| Store your deployments and assets (e.g., personal config files) in one place.
On a new machine — plug in your Grail [.small]#_(heh)_# from a repo or a local dir with one command.

| *Priorities*
| Easily marshal your deployments in order, which is automatically reversed for uninstallation

| *Groups*
| Split your deployment collection into groups to easily handle selective installations

| *Cross-platform*
| Use built-in OS detection mechanism to perform certain tasks on certain distributions or OS families

| *Third-party deployments*
| Attach pre-made deployments from Github (such as our glorious https://github.com/no-simpler/divine-dpls-core[core bundle]) without polluting your precious Grail [.small]#_(heheh)_#

| *Stash*
| Persistent key-value store for use within your deployments

| *Assets*
| Easily separate your deployments into installation logic and dynamic content

| *Queues* and *multitasks*
| Employ built-in mechanisms for deployments that perform a series of tasks

|===

== Installation and uninstallation

=== System requirements

* https://en.wikipedia.org/wiki/Unix-like[Unix-like OS].
Following OS distributions are openly supported:
+
--
** *Debian*
** *Fedora*
** *FreeBSD*
** *macOS*
** *Ubuntu*
--
+
[NOTE]
--
This list is incomplete; you can help by expanding it.
--

* `bash 3.2+` and either `curl` or `wget`
+
[NOTE]
--
`git` is not a hard requirement, but it is not flaccid either.
You can install _Divine.dotfiles_ without `git`.
But then the framework will bug you with suggestions to auto-install it until you relent.
--

=== Installation

To install _Divine.dotfiles_ framework, run the following single command in Terminal:

[source,bash]
----
bash -c 'TMP=$(mktemp); URL=https://raw.github.com/no-simpler/divine-dotfiles/master/lib/install/install.sh; if curl --version &>/dev/null; then curl -fsSL $URL >$TMP; elif wget --version &>/dev/null; then wget -qO $TMP $URL; else printf >&2 "\n==> Error: failed to detect neither curl nor wget\n"; rm -f $TMP; exit 1; fi || { printf >&2 "\n==> Error: failed to download installation script\n"; rm -f $TMP; exit 2; }; chmod +x $TMP && $TMP "$@"; RC=$?; rm -f $TMP; ((RC)) && exit 3 || exit 0' bash
----

Installation is completely safe:

* No files are overwritten.
* This repository is cloned/downloaded.
* One symlink is (optionally) created.

Oh, and you will be prompted for everything.

==== Installation options and overrides

Add flavoring to your installation as such:

[header,cols="<.^1,<.^4",stripes=none]
|===

2+^.^h| Prepend on the left

| `*D_FMWK_DIR=_PATH_*`
| Install framework within `*_PATH_*` instead of default `~/.divine`

| `*D_SHORTCUT_NAME=_CMD_*`
| Name shortcut shell command `*_CMD_*` instead of default `di`

| `*D_SHORTCUT_DIR=_PATH_*`
| Install shortcut shell command within `*_PATH_*` instead of the default way: choosing among directories on `$PATH`

2+^.^h| Append on the right

| `*--yes*`
| Install everything without prompts

| `*--no*`
| Install absolutely nothing

| `*--framework-yes*`
| Install framework without prompt

| `*--framework-no*`
| Install absolutely nothing (synonym of `--no`)

| `*--shortcut-yes*`
| Install shortcut shell command without prompt

| `*--shortcut-no*`
| Skip installing shortcut shell command

| `*--verbose*`
| Increase amount of output

| `*--quiet*`
| [.gray]##_(default)_## Decrease amount of output

|===

=== Uninstallation

To uninstall _Divine.dotfiles_ framework, run the following single command in Terminal:

[source,bash]
----
bash -c 'TMP=$(mktemp); URL=https://raw.github.com/no-simpler/divine-dotfiles/master/lib/uninstall/uninstall.sh; if curl --version &>/dev/null; then curl -fsSL $URL >$TMP; elif wget --version &>/dev/null; then wget -qO $TMP $URL; else printf >&2 "\n==> Error: failed to detect neither curl nor wget\n"; rm -f $TMP; exit 1; fi || { printf >&2 "\n==> Error: failed to download uninstallation script\n"; rm -f $TMP; exit 2; }; chmod +x $TMP && $TMP "$@"; RC=$?; rm -f $TMP; ((RC)) && exit 3 || exit 0' bash
----

Uninstallation removes optional dependencies that might have been installed, and then erases framework directory.

One thing it does *_not_* do is uninstall deployments.
*_You have to uninstall your deployments manually!_*

By default, a copy of your usage files (including <<grail_directory,the Grail>>) is retained, so even if you forget to uninstall deployments, there is potentially a way to remedy that.

==== Uninstallation options and overrides

Add flavoring to your uninstallation as such:

[header,cols="<.^1,<.^4",stripes=none]
|===

2+^.^h| Prepend on the left

| `*D_FMWK_DIR=_PATH_*`
| Uninstall framework within `*_PATH_*` instead of default `~/.divine`

2+^.^h| Append on the right

| `*--yes*`
| Uninstall everything without prompts

| `*--no*`
| Uninstall absolutely nothing

| `*--utils-yes*`
| Uninstall system packages installed by the framework (e.g., `git`) without prompt

| `*--utils-no*`
| Skip uninstalling system packages installed by the framework (e.g., `git`)

| `*--backup-yes*`
| [.gray]##_(default)_## Make backup of usage files (including Grail dir) without prompt

| `*--backup-no*`
| Do not make backup of usage files (including Grail dir) without prompt

| `*--framework-yes*`
| Erase framework directory without prompt

| `*--framework-no*`
| Uninstall absolutely nothing (synonym of `--no`)

| `*--verbose*`
| Increase amount of output

| `*--quiet*`
| [.gray]##_(default)_## Decrease amount of output

|===

=== Joy ride

First timer?
Looking for a feel of what _Divine.dotfiles_ offers?
Here’s a safe and fully removable way to acquaint yourself with the framework:

[source,bash]
----
bash -c 'TMP=$(mktemp); URL=https://raw.github.com/no-simpler/divine-dotfiles/master/lib/install/install.sh; if curl --version &>/dev/null; then curl -fsSL $URL >$TMP; elif wget --version &>/dev/null; then wget -qO $TMP $URL; else printf >&2 "\n==> Error: failed to detect neither curl nor wget\n"; rm -f $TMP; exit 1; fi || { printf >&2 "\n==> Error: failed to download installation script\n"; rm -f $TMP; exit 2; }; chmod +x $TMP && $TMP "$@"; RC=$?; rm -f $TMP; ((RC)) && exit 3 || exit 0' bash --yes \
&& ~/.divine/intervene.sh attach core --yes \
&& ~/.divine/intervene.sh install --yes --with-!
----

[NOTE]
--
This chained command does three things:

. Install the framework without any prompts.
. Attach our illustrious https://github.com/no-simpler/divine-dpls-core[core bundle] of Divine deployments.
. Run deployment installation routine.

Divine deployments *_never overwrite_* pre-existing files on your system without backing them up.

Everything that is backed up is *_automatically restored_* upon uninstallation.
--

All's fair: in case you remain unsatisfied, here are the separate 'undo' steps, in order:

[source,bash]
----
# Uninstall Divine deployments, restoring everything to pre-installation state:
~/.divine/intervene.sh remove --yes --with-!

# Detach Divine deployments from your copy of the framework:
~/.divine/intervene.sh detach core --yes

# Erase the framework without keeping backups:
bash -c 'TMP=$(mktemp); URL=https://raw.github.com/no-simpler/divine-dotfiles/master/lib/uninstall/uninstall.sh; if curl --version &>/dev/null; then curl -fsSL $URL >$TMP; elif wget --version &>/dev/null; then wget -qO $TMP $URL; else printf >&2 "\n==> Error: failed to detect neither curl nor wget\n"; rm -f $TMP; exit 1; fi || { printf >&2 "\n==> Error: failed to download uninstallation script\n"; rm -f $TMP; exit 2; }; chmod +x $TMP && $TMP "$@"; RC=$?; rm -f $TMP; ((RC)) && exit 3 || exit 0' bash --yes --backup-no
----

After the three 'undo' steps have successfully run, there is no trace of _Divine.dotfiles_ on your system.
[.small]#_(Sigh.)_#

== Framework structure

_Divine.dotfiles_ is installed, by default, to `~/.divine/`, and is contained entirely in that directory, except:

* Symlink to the framework's main executable is created somewhere on `$PATH`.
* Your deployments may do to the system pretty much anything.

The framework itself consists of the following main parts:

[header,cols="<.<1,<.<4",stripes=none]
|===

| [#grail_directory]#`~/.divine/*grail/*`#
a| *Grail directory* provides space for user’s deployments and assets.

[NOTE]
--
If you settle on using _Divine.dotfiles_, we recommend taking Grail directory under version control and syncing it, e.g., via cloud services or Github.
--

Sub-structured as follows:

* `*assets/*` — Directory for user's assets, such as config files.
* `*dpls/*` — Directory for user's deployments.
* `.stash.cfg` — Grail stash entries _(file maintained by the framework)_.
* `.stash.cfg.md5` — Grail stash integrity checksum _(file maintained by the framework)_.

| [#state_directory]#`~/.divine/*state/*`#
a| *State directory* carries the state of deployments on current machine.
_(Entire directory is maintained by the framework.)_

Sub-structured as follows:

* `*backups/*` — _Divine.dotfiles_ provides facilities to back up existing files from the system.
This directory stores such backups.
* `*dpl-repos/*` — _Divine.dotfiles_ provides facilities to attach third-party deployments from Github.
This directory stores such deployments.
* `*stash/*` — _Divine.dotfiles_ provides a persistent key-value store for use within deployments.
This directory houses key-value containers.

| [#lib_directory]#`~/.divine/*lib/*`#
| Guts of the framework, structured to the best of creator's ability.
_(Entire directory is, naturally, maintained by the framework.)_

| `~/.divine/intervene.sh`
| *Divine intervention utility*, the command line interface to the framework.
_(File is maintained by the framework.)_

| `[$PATH directory]/di`
| Symlink to the intervention utility, providing an easy access.
This symlink is usually auto-created during framework installation.

|===

== Usage

[[_intervention_utility]]
=== Divine intervention utility `di`

_Divine.dotfiles_ provides command line interface via *Divine intervention utility `di`*.

Intervention utility does:

. *Primary routines* on deployments (and Divinefiles):
.. *Check* whether deployments are installed or not.
.. *Install* deployments.
.. *Uninstall* deployments.
. *Attach/detach* third-party deployments from Github.
. *Plug* in your pre-made Grail directory from a repository or local directory.
. *Update* framework itself, attached deployments, and Grail directory, if it is a cloned repository.

[[_primary_routines]]
=== Checking/installing/removing deployments

Primary routines — bread-and-butter of the framework — launch respective functions on deployments.

[source,bash,subs="verbatim,quotes,attributes"]
----
$ *di* *c*[*heck*]    [-ynqvewf] [--] [*_NAME_*]…

$ *di* *i*[*nstall*]  [-ynqvewf] [--] [*_NAME_*]…

$ *di* *r*[*emove*]   [-ynqvew]  [--] [*_NAME_*]…
----

Accepted values of `*_NAME_*` are (case-insensitive):

* Names of <<_deployments,deployments>>.
* Reserved synonyms for <<_divinefiles,Divinefiles>>: `divinefile`, `dfile`, `df`.
* Single-digit names of <<deployment_groups,deployment groups>>: `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`.
* Without any arguments, all deployments are processed.

Deployments (and Divinefiles) are retrieved from two locations (at any depth):

* Directory for user's deployments: `~/.divine/grail/dpls`.
* Directory for attached deployments: `~/.divine/state/dpl-repos`.

==== Filtering deployments

* Without any arguments, all deployments are processed.
* Particular deployments are requested by listing their names or <<deployment_groups,single-digit group names>>, in any combination.
* <<dangerous_deployments,Dangerous>> deployments are ignored:
** unless requested by name (not by single-digit group name),
** or unless `--with-!`/`-w` option is used.
* Option `--except`/`-e` inverts filtering: all deployments are processed, _except_ those listed.
Note, that without any arguments, this is a no-opt.
+
In this mode, dangerous deployments are still filtered out by default.

==== Primary routine options

Below is the list of primary routine options.
Additional info about routine's behavior is also given.

[header,cols="<.<1,<.<4",stripes=none]
|===

| `*-y*`, `*--yes*`
| Normally, framework prompts user right before sourcing each deployment script.
Other events — like offering an optional framework dependency — also trigger a prompt.

With this option, affirmative answer is assumed to every non-<<urgent_prompt,urgent>> prompt.

Note, that deployments are free to add any number of custom prompts unaffected by this option.

Access within deployments: `$D__OPT_ANSWER` (`true` / `false` / _empty_).

| `*-n*`, `*--no*`
| With this option, negatory answer is assumed to every built-it prompt.
This option is equivalent to a 'dry run' — apart from skip messages, nothing will actually be done.

Access within deployments: `$D__OPT_ANSWER` (`true` / `false` / _empty_).

| `*-f*`, `*--force*`
a| By default, framework does *not*:

* re-install deployments that appear already installed;
* uninstall deployments that appear already not installed;
* process deployments that appear installed by means other than this framework.

This option overrules such considerations.

Access within deployments: `$D__OPT_FORCE` (`true` / `false`).

| `*-e*`, `*--except*`
| This option inverts the behavior of deployment filter: instead of processing only listed deployments, all deployments are processed _except_ listed.

Access within deployments: `$D__OPT_INVERSE` (`true` / `false`).

| `*-w*`, `*--with-!*`
| By default framework ignores <<dangerous_deployments,dangerous deployments>> unless they are named explicitly.
This option disables such behavior.

Access within deployments: `$D__OPT_EXCLAM` (`true` / `false`).

| `*-v*`, `*--verbose*`
| Increase amount of output

Access within deployments: `$D__OPT_QUIET` (`true` / `false`).

| `*-q*`, `*--quiet*`
| [.gray]##_(default)_## Decrease amount of output

Access within deployments: `$D__OPT_QUIET` (`true` / `false`).

|===

[NOTE]
--
Even though every option above serves a function within the framework, it is also up to deployment authors to honor their semantics.
--

[[attaching_deployments]]
=== Attaching third-party deployments

Beside using own deployments, _Divine.dotfiles_ allows to attach (i.e., import) deployments distributed via Github repositories.

[source,bash,subs="verbatim,quotes,attributes"]
----
$ *di* *a*[*ttach*] [-yn] [--] *_REPO_*…

$ *di* *d*[*etach*] [-yn] [--] *_REPO_*…
----

Accepted values of `*_REPO_*` are (case-insensitive):

* Github repository in the form: `no-simpler/divine-dpls-core`.
* Specifically for Divine deployments, a shorthand is accepted:
+
`*_NAME_*` (must not contain `/`) translates to `no-simpler/divine-dpls-*_NAME_*`

Detaching deployments deletes the copy of their repository, but it is up to you to:

* Uninstall the deployments beforehand (re-attach if you forgot).
* Remove any assets that might have been copied into your <<grail_directory,Grail>> assets directory.

[NOTE]
--
Attached repositories are cloned/downloaded into your <<state_directory,state directory>>, but attachment records are stored in <<grail_directory,the Grail>>.
On every launch, intervention utility synchronizes Grail records with actual repositories in state directory.

Thus, by synchronizing Grail between machines, you will have the same set of both custom and attached deployments everywhere.
--

==== Attach/detach routine options

Below is the list of options for attaching/detaching third-party deployments.
Additional info about routine's behavior is also given.

[header,cols="<.<1,<.<4",stripes=none]
|===

| `*-y*`, `*--yes*`
| Normally, framework prompts user right before cloning/downloading repository.
Other events — like offering an optional framework dependency — also trigger a prompt.

With this option, affirmative answer is assumed to every built-it prompt.

| `*-n*`, `*--no*`
| With this option, negatory answer is assumed to every built-it prompt.
This option is equivalent to a 'dry run' — apart from skip messages, nothing will actually be done.

|===

=== Plugging the Grail

If you have a copy of your carefully crafted <<grail_directory,Grail directory>> stored somewhere, _Divine.dotfiles_ lets you easily plug it in.

[source,bash,subs="verbatim,quotes,attributes"]
----
$ *di* *p*[*lug*] [-ynl] [--] *_ADDRESS_*
----

Accepted values of `*_ADDRESS_*` are:

* Github repository in the form: `username/repo-name`.
* Path to a generic git repository.
* Path to a local directory.

Repositories are cloned, directories are copied.
Note, that existing Grail directory will be utterly destroyed in the process.

If provided argument can be interpreted in multiple ways, the framework will iterate over possible options in the order they are given above.

==== Plug routine options

Below is the list of options for plugging in <<grail_directory,Grail directory>>.
Additional info about routine's behavior is also given.

[header,cols="<.<1,<.<4",stripes=none]
|===

| `*-y*`, `*--yes*`
a| Normally, framework prompts user right before overwriting existing Grail directory.
Other events — like offering an optional framework dependency — also trigger a prompt.

With this option, affirmative answer is assumed to every built-it prompt.

[NOTE]
--
If provided argument can be interpreted in multiple ways, the first option will be silently settled upon.
--

| `*-n*`, `*--no*`
| With this option, negatory answer is assumed to every built-it prompt.
This option is equivalent to a 'dry run' — apart from skip messages, nothing will actually be done.

| `*-l*`, `*--link*`
| With this option, symlink is created to the directory, path to which is given, instead of copying it.
In this mode, given argument is not considered as a repository.

|===

=== Updating framework and deployments

[source,bash,subs="verbatim,quotes,attributes"]
----
$ *di* *u*[*pdate*] [-yn] [--] [*f*[*ramework*]] [*g*[*rail*]] [*d*[*eployments*]]
----

Update routine is three-pronged, and you are free to engage any and all of the prongs:

* `*f*` or `*framework*` — pulls latest revision of _Divine.dotfiles_.
* `*g*` or `*grail*` — pulls latest revision of <<grail_directory,Grail directory>>, _if_ it is a <<_plugging_the_grail,plugged>> repository.
* `*d*` or `*deployments*` — pulls latest revision of every <<_attaching_third_party_deployments,_attached_>> deployment repository.
* Without any arguments, all of the above are performed.

==== Updating routine options

Below is the list of options for updating framework, <<grail_directory,the Grail>>, and <<_attaching_third_party_deployments,attached deployments>>.
Additional info about routine's behavior is also given.

[header,cols="<.<1,<.<4",stripes=none]
|===

| `*-y*`, `*--yes*`
a| Normally, framework prompts user right before pulling from remote repository.
Other events — like offering an optional framework dependency — also trigger a prompt.

With this option, affirmative answer is assumed to every built-it prompt.

| `*-n*`, `*--no*`
| With this option, negatory answer is assumed to every built-it prompt.
This option is equivalent to a 'dry run' — apart from skip messages, nothing will actually be done.

|===

== Deployments

A _Divine.dotfiles_ *deployment* is a Bash script named in `*_DPL-NAME_*.dpl.sh` pattern.
`*_DPL_NAME_*` must be non-empty.

To be picked up by the framework, deployments must be located at any depth under two recognized deployment directories:

* `~/.divine/grail/dpls` — user's deployments.
Create your deployments here.
* `~/.divine/state/dpl-repos` — attached third-party deployments.
This one is maintained by the framework.

=== Deployment structure

The minimal valid deployment is an empty file.
As such, it does nothing but appear in framework output.

Deployments are written in Bash syntax (with some limitations on metadata).
Each deployment is sourced by Bash interpreter no more than once per intervention routine.

A deployment is formed by:

* implementing specially named Bash functions (*primaries*);
* assigning to specially named variables (*metadata*).

=== Primary functions

*Primary functions*, or *primaries*, correspond to three fundamental actions performed upon a deployment:

* `d_dpl_check()` — checks whether deployment is installed or not.
* `d_dpl_install()` — installs deployment.
* `d_dpl_remove()` — uninstalls (reverses previous installation of) deployment.

This section includes semantic meanings behind primaries and their return codes.
Feel free to stretch semantic guidelines according to your particular use case.

==== Primary function `d_dpl_check()`

If this function is implemented, it will be called:

* During `check` routine — to determine status and show relevant output.
* During `install` routine — to determine whether installation is necessary/possible.
* During `remove` routine — to determine whether uninstallation is necessary/possible.

Return code of `d_dpl_check()` determines current status of the deployment:

[%header,cols="^.<1,<.<4",stripes=none]
|===

^.^| Return code of `d_dpl_check()`
^.^| Interpretation

| `0`
a| *'Unknown'*: [.gray]##_(default)_## no reliable way to tell whether this deployment is installed or not.

_This return code is assumed if `d_dpl_check()` is not implemented or if unsupported code is returned._

Routines that will proceed further:

* `install`
* `remove`

| `1`
a| *'Installed'*: as it stands, intended goal of installing this deployment is entirely achieved.

Routines that will proceed further:

* `remove`

| `2`
a| *'Not installed'*: as it stands, intended goal of installing this deployment is entirely not achieved.

Routines that will proceed further:

* `install`

| `3`
a| *'Irrelevant'*: processing this deployment in current environment does not make sense.

This code is appropriate, for example, if current OS is unsupported.

None of the routines will proceed further.

| `4`
a| *'Partly installed'*: as it stands, intended goal of installing this deployment is partly achieved and partly not achieved.

This code differs from 'Unknown' in semantics and output styling.

Routines that will proceed further:

* `install`
* `remove`

|===

==== Primary function `d_dpl_install()`

If this function is implemented, it will be called during `install` routine — to achieve the intended goal of this deployment.

Return code of `d_dpl_install()` determines output of `install` routine:

[%header,cols="^.<1,<.<4",stripes=none]
|===

^.^| Return code of `d_dpl_install()`
^.^| Interpretation

| `0`
| *'Successfully installed'*: [.gray]##_(default)_## intended goal of installing this deployment is entirely achieved.

_This return code is assumed if `d_dpl_install()` is not implemented or if unsupported code is returned._

| `1`
| *'Failed to install'*: intended goal of installing this deployment is _not entirely_ achieved due to error.

| `2`
| *'Skipped'*: intended goal of installing this deployment is _entirely not_ achieved because nothing has been done.

| `100`
a| *'Reboot needed'*: same as 'Successfully installed', except:

* Intervention will gracefully shut down without moving past this deployment.
* User will be asked to reboot the machine and continue afterward.

| `101`
a| *'User attention needed'*: same as 'Successfully installed', except:

* Intervention will gracefully shut down without moving past this deployment.
* Deployment is expected to print explanation to `stdout`.

| `102`
a| *'Critical failure'*: same as 'Failed to install', except:

* Intervention will shut down without moving past this deployment.
* Output will mention critical failure.

|===

==== Primary function `d_dpl_remove()`

If this function is implemented, it will be called during `remove` routine — to reverse the effects of previously installing this deployment.

Return code of `d_dpl_remove()` determines output of `remove` routine:

[%header,cols="^.<1,<.<4",stripes=none]
|===

^.^| Return code of `d_dpl_remove()`
^.^| Interpretation

| `0`
| *'Successfully installed'*: [.gray]##_(default)_## intended goal of installing this deployment is entirely achieved.

_This return code is assumed if `d_dpl_remove()` is not implemented or if unsupported code is returned._

| `1`
| *'Failed to install'*: intended goal of installing this deployment is _not entirely_ achieved due to error.

| `2`
| *'Skipped'*: intended goal of installing this deployment is _entirely not_ achieved because nothing has been done.

| `100`
a| *'Reboot needed'*: same as 'Successfully installed', except:

* Intervention will gracefully shut down without moving past this deployment.
* User will be asked to reboot the machine and continue afterward.

| `101`
a| *'User attention needed'*: same as 'Successfully installed', except:

* Intervention will gracefully shut down without moving past this deployment.
* Deployment is expected to print explanation to `stdout`.

| `102`
a| *'Critical failure'*: same as 'Failed to install', except:

* Intervention will shut down without moving past this deployment.
* Output will mention critical failure.

|===

=== Deployment metadata

*Deployment metadata* (posing as variable assignments) alter deployment's appearance and behavior:

* `D_DPL_NAME` — explicit name for the deployment.
* `D_DPL_DESC` — one-line description of the deployment.
* `D_DPL_PRIORITY` — priority of the deployment (non-negative integer).
* `D_DPL_FLAGS` — one-character flags, causing special treatment.
* `D_DPL_WARNING` — one-line cautionary message about this deployment.

[NOTE]
--
Although all deployment metadata look like Bash variable assignments, they are in face extracted from the file _before_ it is interpreted by Bash.

For each reserved 'variable' name, first line that looks like the usual Bash assignment is used.

With that in mind, follow these simple rules for deployment metadata:

* Write one 'assignment' per line, without line continuation.
* Do not use Bash substitutions or comments.
* Avoid leading and trailing whitespace, as well as whitespace around the `=`.
* Matching quotes around the value are allowed (they are stripped in the processing).
--

==== Deployment name and description

[source,bash]
----
D_DPL_NAME=example
D_DPL_DESC='Simple description that shows in deployment prompts'
----

While *description* is mostly cosmetic, deployment *name* is very important.
It is the single unique identifier for every deployment, and is used to invoke primary routines on it.
As such, the framework forbids having more than one deployment sharing a name.

If deployment name is not provided explicitly, file name is used instead, sans `.dpl.sh` suffix.
Deployment names are case insensitive.

==== Deployment priority

[source,bash]
----
D_DPL_PRIORITY=420
----

Priority is the way to impose order on deployment processing.

During `check` and `install` routines, deployments are sorted in ascending order (smaller integer values go first).
During `uninstall` routine, the order is fully reversed.
Order of deployments with the same priority is undefined.

Priority must be a non-negative integer, otherwise it falls back to the default value of `4096`.

==== Deployment flags

[source,bash]
----
D_DPL_FLAGS=ci!89
----

Flags alter some of the framework's behavior toward the deployment.

* A flag is a single non-whitespace character.
* Any number of flags can be put together in any order.
* Repeating a flag does not bear any additional significance.
* There is no way to unset a flag, apart from not setting it.
* Unsupported flags are silently ignored.

Below is the exhaustive rundown of supported flags and their effects.

[%header,cols="^.<1,<.<4",stripes=none]
|===

^.^| Flag character (regex)
^.^| Effect on deployment handling

| [#deployment_groups]#`[0-9]`#
a| Assigns the deployment to one of the ten single-digit *groups*.
Groups of deployments may be processed together by referring to them by that group's digit in place of deployment name.

[NOTE]
--
Consequently, a deployment may not be named with a single digit.
The framework guards against using reserved deployment names.
--

| [#dangerous_deployments]#`!`#
| Marks the deployment as *dangerous*.
By default, framework ignores dangerous deployments unless they are listed by name or by name of their group.
Another way to include dangerous deployments is the `--with-!`/`-w` option on intervention utility.

| [#urgent_prompt]#`[cira]`#
a| Intervention utility has the `--yes`/`-y` option that effectively skips all normal prompts and confirmations.
It is possible to force the appearance of an *urgent prompt* before the deployment is sourced regardless of said option.
To do so, use any of these flags:

* `c` — always prompt during `check` routine.
* `i` — always prompt during `install` routine.
* `r` — always prompt during `remove` routine.
* `a` — all of the avove.

When a prompt is forced by a flag, it remains urgent even without `--yes` option.
Urgent prompts are styled to stand out a bit more in terminal.

|===

==== Deployment warning

[source,bash]
----
D_DPL_WARNING="Warning for 'urgent' prompts forced by a flag"
----

If such warning is provided, it will accompany every urgent prompt enforced by a deployment flag.

== Divinefiles

A *Divinefile* is a special kind of deployment.
Its purpose is akin to that of https://github.com/Homebrew/homebrew-bundle[Brewfile] or https://bundler.io/gemfile.html[Gemfile].
A Divinefile is a manifest of system utilities to be maintained using supported system package managers.

* A Divinefile must be named, well, `Divinefile`.
* There can absolutely be more than one — their contents are effectively merged.
* The framework picks up every Divinefile located at any depth under two recognized deployment directories:
** `~/.divine/grail/dpls` — user's Divinefiles. Create yours here.
** `~/.divine/state/dpl-repos` — attached third-party Divinefiles.
* As a kind of deployment, Divinefiles are referred to by their collective reserved name, `Divinefile` (or synonyms `dfile`, `df`).

[NOTE]
--
Yes, you also cannot name regular deployments `divinefile`, `dfile`, or `df`.
The framework guards against using reserved deployment names.
--

=== Divinefile usage

During an intervention, Divinefiles may only be referred to collectively.
They are processed in their merged entirety, or not processed at all.

You can nevertheless assign deployment-style *priorities and flags* to individual packages within Divinefiles.
Packages are intertwined with regular deployments in a shared workflow.

[NOTE]
--
For more complex system package installations, e.g., involving particular versions or special package manager options, use regular deployments.
--

=== Divinefile syntax

Divinefiles are processed in terms of lines.

Simplest line contains a list of whitespace-delimited package names.
Each package is then individually checked/installed/uninstalled during relevant routines:

[source,bash]
----
pkg1 pkg2
----

[NOTE]
--
For Divinefiles in general, whitespace rules are fairly permissive.
Whitespace separates ``WORD``s and is otherwise insignificant.
--

==== Alt-lists

Within a line, each `|` (vartical bar) starts an alt-list.
An alt-list is specific to a particular package manager.
If an alt-list is provided for currently detected package manager, it overrides the original list entirely.

[source,bash]
----
pkg1 | apt-get: pkg1 pkg2 | dnf: pkg3
----

Within an alt-list, everything to the left of first `:` (colon) is read as package manager name.
Everything to the right — as whitespace-delimited alt-list of package names for that package manager

[NOTE]
--
Package manager name is matched against `$D__OS_PKGMGR` built-in variable.
--

==== Package priority and flags

Similarly to regular deployments, each valid line in Divinefile may have priority and flags.
These may be set at the beginning of the line (before any package lists) within individual pairs of parentheses:

[source,bash]
----
(priority: 1000)              pkg1 pkg2

(flags: ir)                   pkg3 | yum: pkg4

(priority: 500) (flags: r)    pkg5
----

With regard to flags, a shorthand is provided, that works by *appending* provided flags as opposed to overriding them as is normal:

[source,bash]
----
(i) pkg1        # Parentheses must not contain ':'

( r0! ) pkg2    # Multiple flags may be given too
----

==== OS-specific packages

Lines may be made exclusive to particular OS family or distribution.
Multiple OS's may be given by separating with vartical bars:

[source,bash]
----
(os: debian)      pkg1

(os: macos|bsd)   pkg2

(os: all)         pkg3    # Keywords 'all'/'any' are reserved to denote any OS
----

[NOTE]
--
Each OS name is matched against `$D\__OS_FAMILY` and `$D__OS_DISTRO` built-in variables.
Single match against any of the two is sufficient.
--

[[kv]]
==== Key-values

All parenthesized key-values, when they appear on a line without any package lists, come into effect until the end of the file, or until another value is assigned to the same key:

[source,bash]
----
pkg1                  # Any OS, priority 4096 (default)

( os : macos )(priority:333)    ## These will remain in effect until 
                                #. end of file or until overridden

pkg2                  # macOS-only, priority 333
(priority:69) pkg3    # macOS-only, priority 69
pkg4                  # macOS-only, priority 333
----

==== Comments and line continuation

Hash/pound symbol (`#`) comments out the rest of the line.

A line may be 'glued' to the next by terminating it with a backslash (`\`):
[source,bash]
----
(os: fedora) \    ## This is a single logical line
pkg1 pkg2    \    #. spanning three actual lines
| yum: pkg3       #. (yes, even with comments attached like this)
----

==== Divinefile example

[source,bash]
----
git                       ## Means:
                          #.  * priority: 4096 (default)
                          #.  * packages: git

(priority:300)  \         ## Means:
(r)             \         #.  * priority: 300
node            \         #.  * flags: 'always prompt before removing'
| apt-get: nodejs npm     #.  * packages (on apt-get): nodejs npm
                          #.  * packages (anywhere else): node
----

== Advanced features

_Divine.dotfiles_ offers mechanisms that facilitate creation of better, stronger, faster deployments.

=== Deployment guidelines

A deployment file is interpreted by Bash no more than once per intervention.
Sourcing occurs as late as possible, after exhausting excuses to skip it.
A subshell is created for every deployment, shielding other deployments from it.

It is good style to isolate all deployment logic within functions and global variables, and then call/use them within <<_primary_functions,primary functions>>.

==== Naming convention

_Divine.dotfiles_ uses a naming convention in its own code:

* `*D_*` prefix — for names of global variables;
* `*d_*` prefix — for names of functions.

Whenever the framework does _not_ expect you to reassign a global variable or re-implement a function, the underscore is doubled:

* `*D__*` prefix — for names of read-only internal variables;
* `*d__*` prefix — for names of call-only internal functions.

[NOTE]
--
Some of the most used framework functions have grown so attached to their `d` prefix, that they omit the underscores altogether.
Examples are: `dprint_*` family of functions, `dprompt`, `dstash`, `dln`, `dcp`, etc.

All such functions are call-only, i.e., *not* for re-implementation.
--

=== Variables available to deployments

The following variables are available/recognized in each deployment:

[%header,cols="<.<1,<.<4",stripes=none]
|===

^.^| Variable name
^.^| Value description

2+^.^h| <<_deployment_metadata,Deployment metadata>>

| `*D_DPL_NAME*`
| Explicit name for the deployment.

This variable will be non-empty even if there is no assignment within the file.

| `*D_DPL_DESC*`
| One-line description of the deployment.

| `*D_DPL_PRIORITY*`
| Priority of the deployment (non-negative integer).

This variable will be non-empty even if there is no assignment within the file.

| `*D_DPL_FLAGS*`
| One-character flags, causing special treatment.

| `*D_DPL_WARNING*`
| One-line cautionary message about this deployment.

2+^.^h| Special directory paths

| `*D__DPL_DIR*`
| Absolute path to directory containing `*.dpl.sh` file.

| `*D__DPL_ASSET_DIR*`
| Generated absolute path to directory assigned to hold assets of current deployment.

Located within <<grail_directory,the Grail>>, specifically `grail/assets/*_D_DPL_NAME_*/`.

| `*D__DPL_BACKUP_DIR*`
| Generated absolute path to directory assigned to hold backups of current deployment.

Located within <<state_directory,state directory>>, specifically `state/backups/*_D_DPL_NAME_*/`.

2+^.^h| Special file paths

| `*D__DPL_SH_PATH*`
| Absolute path to `*.dpl.sh` file.

| `*D__DPL_MNF_PATH*`
a| Generated absolute path to asset manifest of current deployment.
This path does not necessarily exist.

Same as `*_D__DPL_SH_PATH_*`, but with suffix changed to `*.dpl.mnf`.

[NOTE]
--
Asset manifests are also processed by other internal routines, which don't source deployments.
Making path to asset manifest dynamic would break those routines.

Thus, path schema of asset manifests is locked, and this variable is read-only.
--

| `*D_DPL_QUE_PATH*`
a| Generated absolute path to queue manifest of current deployment.
This path does not necessarily exist.

Same as `*_D__DPL_SH_PATH_*`, but with suffix changed to `*.dpl.que`.

[NOTE]
--
Queue manifests are processed only after their deployment file is sourced.

You are free to adjust this path to your liking.
--

2+^.^h| [#detected_os]#Detected operating system (OS)#

| [#var_os_family]#`*D__OS_FAMILY*`#
a| Broad description of current OS.

Exhaustive list of possible values:

* `bsd` — https://en.wikipedia.org/wiki/List_of_BSD_operating_systems[BSD descendants]
* `cygwin` — https://en.wikipedia.org/wiki/Cygwin[Cygwin]
* `linux` — https://en.wikipedia.org/wiki/Linux[Linux]
* `macos` — https://en.wikipedia.org/wiki/MacOS[macOS]
* `msys` — https://en.wikipedia.org/wiki/MinGW[Minimalist GNU for Windows]
* `solaris` — https://en.wikipedia.org/wiki/Solaris_(operating_system)[Oracle Solaris]
* `wsl` — https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux[Windows Subsystem for Linux]

[NOTE]
--
Note that `linux` and `wsl` are separate entries.
Check for both to determine whether currently under modern Linux, e.g.:

[source,bash,subs="verbatim,attributes"]
----
case $D__OS_FAMILY in
  linux{vbar}wsl)   echo linux;;
  *)           echo other;;
esac
----

--

| [#var_os_distro]#`*D__OS_DISTRO*`#
a| Best guess on the name of the current OS distribution.

Exhaustive list of possible values:

* `debian`
* `fedora`
* `freebsd`
* `macos`
* `ubuntu`
* _empty_ — failed to reliably detect a supported distribution

[NOTE]
--
This list is incomplete; you can help by expanding it.
--

| [#var_os_pkgmgr]#`*D__OS_PKGMGR*`#
a| Name of supported system package manager available on current system.

Exhaustive list of possible values:

* `apt-get`
* `brew`
* `dnf`
* `pkg`
* `yum`
* _empty_ — failed to reliably detect a supported package manager

[NOTE]
--
This list is incomplete; you can help by expanding it.
--

When this variable is non-empty, you also have the built-in <<func_os_pkgmgr,package manager wrapper>>, `d__os_pkgmgr()`, at your disposal.

2+^.^h| Recognized marker variables

| [#var_another_prompt]#`D_DPL_NEEDS_ANOTHER_PROMPT`#
| Works only during `install`/`remove` <<_primary_routines,routine>> and only if set within `d_dpl_check()` primary.

Set this variable to `true` to trigger an <<urgent_prompt,urgent prompt>> before the framework proceeds to (un)installation.

| [#var_another_warning]#`D_DPL_NEEDS_ANOTHER_WARNING`#
| Works only during `install`/`remove` <<_primary_routines,routine>> and only if set within `d_dpl_check()` primary.

If `*_D_DPL_NEEDS_ANOTHER_PROMPT_*` is set to `true` and this variable is non-empty, then this textual warning is shown to the user.

| [#var_user_or_os]#`D_DPL_INSTALLED_BY_USER_OR_OS`#
a| Works only if set within `d_dpl_check()` primary.

Set this variable to `true` to signal to the framework: whatever parts of current deployment are installed, have been installed by other methods, not by this framework.

This affects behavior of the following return codes of `d_dpl_check()`:

* `1` ('installed') — prohibits uninstalling;
* `4` ('partly installed') — prohibits uninstalling.

[NOTE]
--
This is useful for deployments designed to not interfere with manual tinkering.
--

2+^.^h| Parameters of current request

| `*D__REQ_ROUTINE*`
a| Name of <<_primary_routines,primary routine>> currently being executed:

* `check`
* `install`
* `remove`

| `*D__OPT_FORCE*`
a| Whether `-f` / `--force` option is provided:

* `true`
* `false`

| `*D__OPT_QUIET*`
a| Which verbosity options are settled upon:

* `true` — `-q` / `--quiet` / no verbosity options
* `false` — `-v` / `--verbose`

| `*D__OPT_EXCLAM*`
a| Whether `-w` / `--with-!` option is provided to process <<dangerous_deployments,dangerous>> deployments:

* `true`
* `false`

| `*D__OPT_ANSWER*`
a| Whether blanket answer is given to all non-<<urgent_prompt,urgent>> built-in prompts:

* `true` — `-y` / `--yes`
* `false` — `-n` / `--no`
* _empty_ — no blanket answer

|===

=== Functions available to deployments

==== `dprint` family of functions

Functions named with prefix `dprint_` serve to unify styling and behavior of output across _Divine.dotfiles_.
They all print to `stderr`.

You are advised to serve all output of your deployments through one of these, in keeping with their semantics.

[source,bash,subs="verbatim,quotes,attributes"]
----
*dprint_debug*    [-l] [-n] [*_CHUNK_*|-n|-i]...    {dhs} Debug message (appears 
                                              {hs}. only in --verbose mode)

*dprint_alert*         [-n] [*_CHUNK_*|-n|-i]...    {hs} Notable event/problem

*dprint_skip*          [-n] [*_CHUNK_*|-n|-i]...    {hs} Notable skip

*dprint_success*       [-n] [*_CHUNK_*|-n|-i]...    {hs} Notable success

*dprint_failure*       [-n] [*_CHUNK_*|-n|-i]...    {hs} Notable failure

*dprint_sudo*          [-n] [*_CHUNK_*|-n|-i]...    {dhs} Warning of upcoming sudo 
                                              {hs}. password prompt (appears only 
                                              {hs}. when caller currently does not
                                              {hs}. have sudo privelege)
----

.Example output of using a `dprint_*` function (coloring omitted)
[source,bash,subs="verbatim,quotes,attributes"]
----
$ dprint_debug -l -n 'Extracting archive from:' -i "$archive_path" \
-n 'to your home directory'

*==>* Extracting archive from:
        /home/user/downloads/filename.tar.gz
    to your home directory
----

The `dprint` functions have the following *in common*:

* The output is prepended with a thematically styled 'fat' arrow: `=\=>`.
* The output message is assembled from given ``*_CHUNK_*``s, which are just strings.
* Special `*_CHUNK_*`, `-n`, inserts a line break.
+
If `-n` is the very first chunk, line break appears before the introductory arrow.
* Special `*_CHUNK_*`, `-i`, inserts a line break followed by four-space indentation.
* In the produced message, normal chunks are separated with single space.
* Unrecognized options are treated as literal chunks.

The `dprint` functions *differ* in the following:

* `dprint_debug` honors current verbosity mode, as stored in `$D__OPT_QUIET`.
You can force `dprint_debug` to always print by providing `-l` option as the very first argument.
+
All other `dprint` functions print their message regardless of verbosity.
* Entire message of `dprint_debug` is colored to stand out.
+
All other `dprint` functions print their message in terminal's font color.
* `dprint_sudo` prints its message only if calling context has no superuser priveleges.
Otherwise, nothing is printed.
* `dprint_sudo` is the only one that provides a default message if no chunks are given.
It reads:
+
`*=\=>* Sudo password is required`

The `dprint` functions carry following *semantics*:

[%header,cols="<.<1,<.<4",stripes=none]
|===

^.^| Function
^.^| Semantics

| `*dprint_debug*`
a| `[.blue]#*=\=>* Stage of internal logic#`

The intention is to quickly locate the point of failure, in case an error appears.
Only printed in verbose mode.

Put this everywhere: it won't show by default anyway.
| `*dprint_alert*`
a| `[.yellow]#*=\=>*# Notable non-fatal event/problem`

Sprinkle this sparingly, or it will likely be ignored.
| `*dprint_skip*`
a| `[.white]#*=\=>*# Notable non-fatal skipping of logic`

Use this if the skip is not problematic.
| `*dprint_success*`
a| `[.green]#*=\=>*# Notable success`

Avoid this unless the success is extraordinary.
| `*dprint_failure*`
a| `[.red]#*=\=>*# Notable failure, fatal or not`

Issue this on everything that is abnormal.
| `*dprint_sudo*`
a| `[.yellow]#*=\=>*# Warning of upcoming sudo password prompt`

Only printed when caller currently lacks sudo priveleges.

Prepend this to your priveleged calls to inform user of why they need to enter their password.

|===

[NOTE]
--
Notice the word '_notable_' used throughout.
In general, it is *not* _notable_ when your deployment works as expected.
--

==== `dprompt` function

Function `dprompt` serves to unify styling and behavior of user prompts across _Divine.dotfiles_.
It prints to `stderr`.

You are advised to serve all user prompts of your deployments through this function.

[source,bash,subs="verbatim,quotes,attributes"]
----
*dprompt* [-a *_ANSWER_*] [-p *_PROMPT_*] [-c *_COLOR_*] [-brkyq]... \
  [--] [-n] [*_CHUNKS_*|-n|-i]...
----

Interactively promts user for either:

* yes/no answer (default prompt message: `Proceed?`)
* any key press (default prompt message: `Press any key to continue`)

.Example output of using a `dprompt` function
[source,bash,subs="verbatim,quotes,attributes"]
----
$ dprompt --prompt 'Are you sure?' --bare --or-quit -- -n 'Next step is risky!'

*==>* Next step is risky!
    Are you sure? [y/n/q]
----

Prints introductory message composed from ``*_CHUNK_*``s (these work the same as in `dprint` functions).
Then, prints the prompt message followed by declaration of expected response, e.g., `[y/n]`.

Returns:

* `0` on affirmative answer,
* `1` on negatory answer,
* `2` on special 'quit' answer (enabled by `--or-quit` option).

Below is the list of `dprompt` options.
Unrecognized options are silently ignored.

[%header,cols="<.<1,<.<3",stripes=none]
|===

^.^| `dprompt` option
^.^| Description

a| `*-a* *_ANSWER_*`,

`*--answer* *_ANSWER_*`
a| * If `*_ANSWER_*` is `true`, returns `0` immediately.
* If `*_ANSWER_*` is `false`, returns `1` immediately.
* Otherwise, proceeds with prompting.

[NOTE]
--
Call `dprompt --answer "$D__OPT_ANSWER"` to make the prompt honor `--yes`/`--no` options of the <<_intervention_utility,intervention utility>>.
--

a| `*-p* *_PROMPT_*`,

`*--prompt* *_PROMPT_*`
a| Customizes prompt text.
Limit this to a few words, e.g., `Are you sure?`.
Long-winded descriptions are better served in chunks as regular arguments.

a| `*-c* *_COLOR_*`,

`*--color* *_COLOR_*`
a| Uses one of the built-in colors in styling of the prompt: `$BLACK`, `$RED`, `$GREEN`, `$YELLOW` (_default_), `$BLUE`, `$MAGENTA`, `$CYAN`, `$WHITE`.

a| `*-b*`
a| (_repeatable_) Gradually removes built-in coloring and bolding effects.
Depending on number of `-b` options, the following styling is used:

* 0:  bold, color, inverted color
* 1:  bold, color
* 2:  bold
* 3:  color
* 4+: _none_, synonym of `--bare`

a| `*--bare*`
a| Completely removes built-in coloring and bolding from the prompt.
Synonym of `-bbbb`.

a| `*-r*`, `*--arrow*`
a| Always prepend 'fat' arrow, `=\=>`, to the prompt.
Without this option, the arrow is only printed when there is at least one non-option argument.

a| `*-k*`, `*--any-key*`
a| Special mode: return `0` on any key press after the prompt.

With this option `0` is immediately returned for both `true` and `false` values of `--answer` option.

a| `*-y*`, `*--yes-no*`
a| Default mode: yes or no prompt.

a| `*-q*`, `*--or-quit*`
a| In default mode, this option introduces the third option: `q` (stands for 'quit').
If user presses `q`, code `2` is returned by `dprompt`.

|===

==== `dmd5` function

Function `dmd5` provides a cross-platform way of calculating an md5 checksum of a file or a string.

It relies on at least one of the following utilities being available in the system: `md5sum` or `md5` or `openssl`.

[source,bash,subs="verbatim,quotes,attributes"]
----
*dmd5* [-s *_STRING_*] | [*_PATH_*]
----

* One checksum is calculated per call.
* Either a string or a path to a file may be given.
* It is up to you to ensure that path exists and is readable.
* Checksum is printed to `stdout`.

Returns zero on success and non-zero if something goes wrong.

==== `dstash` function

Function `dstash` is so important that it deserved its <<_stash,own section>>.

=== Stash

_Divine.dotfiles_ provides a persistent key-value storage and retrieval system.
It is based in file system, i.e., data is stored in files.
It is accessible within deployments via `dstash` function.

[source,bash,subs="verbatim,quotes,attributes"]
----
*dstash* *ready*|*has*|*set*|*add*|*get*|*list*|*unset*|*clear* [-rgs] [ *_KEY_* [*_VALUE_*] ]
----

[#stash_types]#There are three levels of stashing system#:

* *Deployment stash* — exclusive to current deployment on current machine.
This is the default.
+
Stored in `state/stash/*_DPL-NAME_*/.stash.cfg`.
* *Root stash* — shared by all deployments on current machine.
+
Stored in `state/stash/.stash.cfg`.
* *Grail stash* — shared by all deployments across all machines that use the same <<grail_directory,Grail>>.
+
Stored in `grail/.stash.cfg`.

Rules of key-value store are:

* Keys must consist of: alphanumeric characters, underscore (`_`), and hyphen (`-`).
* Values must not exceed single line of text, but are otherwise unrestricted, and may be empty.
* Multiple instances of a key are allowed, values may be duplicate.

Depending on first argument, usage is as follows.

[%header,cols="<.<1,<.<3",stripes=none]
|===

^.^| `dstash` arguments
^.^| Description

| `*ready*`
| (_default task_) Checks that stashing system is primed and ready.

Returns `0` if stash is ready, or `2` if not.

| `*has* *_KEY_*`
| Checks if stash contains at least one `*_KEY_*` with any value.

Returns `0` if so, or `1` otherwise.

| `*set* *_KEY_* [*_VALUE_*]`
| Ensures presence of single `*_KEY_*` and sets it to `*_VALUE_*`.

Returns `0` on success, or `1` otherwise.

| `*add* *_KEY_* [*_VALUE_*]`
| Adds one instance of `*_KEY_*` and sets it to `*_VALUE_*`.

Returns `0` on success, or `1` otherwise.

| `*get* *_KEY_*`
| Prints the value of the first instance of `*_KEY_*` to `stdout`.

Returns `0` on success (even if nothing was printed), or `1` otherwise.

| `*list* *_KEY_*`
| Prints each value of `*_KEY_*` on a line to `stdout`.

Returns `0` on success (even if nothing was printed), or `1` otherwise.

| `*unset* *_KEY_* [*_VALUE_*]`
| If `*_VALUE_*` is provided: removes each instance of `*_KEY_*` containing that value.

Without `*_VALUE_*`: removes all instances of `*_KEY_*`.

Returns `0` on success (even if nothing was removed), or `1` otherwise.

| `*clear*`
| Clears all records from this stash.

|===

Below is the list of `dstash` options.

[%header,cols="<.<1,<.<3",stripes=none]
|===

^.^| `dstash` option
^.^| Description

a| `*-s*`, `*--skip-checks*`
a| Normally, each invocation of `dstash` (with any arguments) starts with integrity check.
For repeated calls within a deployment, such checks become redundant.
After ensuring that `dstash ready`, use this option on every subsequent call to `dstash` to forego integrity checks.

a| `*-r*`, `*--root*`
a| Works with <<stash_types,root stash>> instead of default deployment stash.

a| `*-g*`, `*--grail*`
a| Works with <<stash_types,Grail stash>> instead of default deployment stash.

|===

[NOTE]
--
Records of attaching deployments are stored in <<stash_types,Grail stash>>.

Records of installing optional framework dependencies are stored in <<stash_types,root stash>>.
--

=== Manifests

_Divine.dotfiles_ introduces a simple markup language for special files called *manifests*.

There are three types of special files that are manifests:

* <<_divinefiles, Divinefiles>>.
* <<_asset_manifests, Asset manifests>>.
* <<_queue_manifests, Queue manifests>>.

While they differ in purpose and supported features, all types of manifests share basic syntax, as they are internally parsed by the same engine.

==== Manifest syntax

Manifests are processed in terms of lines.
Simplest line contains an *entry* of some kind.

Whitespace rules are fairly permissive.
Any amount of leading and trailing whitespace is allowed and ignored.
Within an entry, whitespace is preserved.

[source]
----
entry1
entry2
entry with whitespace
  indented entry will not contain indentation
----

[[kv]]
==== Key-values

Whenever a line starts with an opening parenthesis `(` and contains a closing one `)`, what's between them is interpreted as a *key-value* pair.
Key-values are used to qualify entries and provide additional info.

A key-value is separated into key and value by the first occurrence of `:` (colon) within the parentheses.

There may be more than one key-value per line, but they must precede the actual entry.
Key-values that precede an entry affect only that entry.
Key-values that occupy their own line comeinto effect for the rest of the document, or unless overridden.

[source,bash]
----
entry1                  # This entry is not affected by any key-values
(color: red) entry2     # This entry has color set to red

(color: blue)           # This line sets color to blue for the following lines
entry3                  # Color is blue
(color: green) entry4   # Color is green
entry5                  # Color is blue

(color:)
entry6                  ## These entries are once again
entry7                  #. not affected by any key-values
----

[NOTE]
--
There are a few keys that are universal to all types of manifests.
They are described below.

Particular kinds of manifests support additional keys.
--

==== OS-specific entries

Key `os` makes entries specific to particular operating systems.
Multiple OS's may be given by separating with vartical bars.
Entire list of OS's may be negated (inverted) by prepending it with a `!`.

[source,bash]
----
(os: debian)          entry1    # Relevant only on Debian

(os: macos|bsd)       entry2    # Relevant only on macOS or BSD

(os: ! linux | wsl)   entry3    # Relevant everywhere except Linux or WSL

(os: all)             entry4    ## Keywords 'all'/'any' are reserved to denote 
                                #. any OS. This is synonymous to empty list.
----

[NOTE]
--
OS names are matched against <<var_os_family,`$D\__OS_FAMILY`>> and <<var_os_distro,`$D__OS_DISTRO`>> built-in variables.
Single match against any of the two is sufficient.
--

==== Entry flags

Key `flags` adds a string of single-character flags to the entries.

Flags specifically have a *shorthand*: whenever a key-value does not contain a `:` (colon) separator (i.e., there is no key), content of parentheses is interpreted as `flags`.
Note, however that the shorthand (and only the shorthand) works by *appending* provided flags to the current value instead of substituting them.

[source,bash]
----
(flags: i!0)  entry1    # Flags: i, !, 0

(flags: a)
              entry2    # Flags: a
       (b)
       (c)    entry3    # Flags: a, b, c
              entry4    # Flags: a, b
(flags: d)    entry5    # Flags: d
              entry6    # Flags: a, b
----

==== Comments and line continuation

Hash/pound symbol (`#`) comments out the rest of the line.

A line may be 'glued' to the next by terminating it with a backslash (`\`).
Whitespace and comment are allowed to follow the backslash.

[source,bash]
----
(os: fedora)  \   ## This is a single logical line
lengthy entry \   #. spanning three physical lines
text              #. (yes, even with comments attached like this)
----

=== Assets

If you develop deployments for distribution, you will soon encounter the problem of separating more-or-less static deployment logic from dynamic deployment assets.

Lets study an example deployment that symlinks a configuration file into the system.
It would be desirable to copy a sample of that configuration file into user's <<grail_directory,Grail directory>>, and then create a symlink to the copy.
The user would then be free to inspect, modify, and synchronize that copy.
At the same time, the deployment file is better kept within <<state_directory,state directory>>, where it would be easily updated by the framework.

To facilitate separation of deployment logic and assets, _Divine.dotfiles_ offers the mechanism of *asset manifests*.

==== Asset manifests

An *asset manifest* is a text file located in the same directory as the deployment file and named the same, except for exchanging `.dpl.sh` suffix for `.dpl.mnf`.

Contents of an asset manifest describe a set of *assets* (files and directories) within the manifest's directory.
Whenever such manifest is processed, the framework ensures that a copy of each asset is present within the deployment's designated asset directory: `grail/assets/*_DPL-NAME_*/`.
Note, that the framework never overwrites assets that are already present at destination.

Processing of asset manifests occurs:

* During <<primary_routines,primary routines>>, after sourcing deployment file, but before calling any of the <<_primary_functions,primary functions>>.
* During <<attaching_deployments,attaching of deployments>>, so that the assets of newly introduced deployments are immediately present in <<grail_directory,the Grail>>.

==== Asset manifest syntax

Asset manifests follow the general <<_manifest_syntax,manifest syntax>>.

Every entry is a *path* that is resolved relative to the deployment directory.
When assets are copied to deployment's asset directory, their relative path is preserved.
If you want your paths to be resolved relative to some sub-path, which you don't want to be carried over to destination, specify that sub-path in the `prefix` key.

Two type of paths are accepted: *concrete* paths and *regex* patterns.
To be interpreted as a regex pattern, a path must be <<_entry_flags,flagged>> with `r` character.
Under the hood, patterns are fed to the http://man7.org/linux/man-pages/man1/find.1.html[find] utility, specifically, the `-path` directive.

.Example of asset manifest
[source]
----
file1.txt           ## These files will be copied from deployment directory
file2.txt           #. into the root of asset directory

(r) configs/*.cfg   ## Any .cfg files will be copied into 'configs/'

(prefix: images)
img1.jpg            ## These two files will be grabbed from 'images/' directory
img2.jpg            #. and copied into the root of asset directory
----

[NOTE]
--
Framework enforces the presence of assets identified by concrete paths.
If any of such assets is missing, deployment will not be allowed to proceed.

Regex patterns are more permissive: they may match zero assets, and no error will be raised.
--

=== Queues

==== Generic queue

==== Queue manifests

==== Link queue

==== Copy queue

==== Split queue

=== Multitask

== Ways to contribute

=== OS detection and support
