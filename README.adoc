= Divine.dotfiles
:author: Grove Pyree
:email: grayarea@protonmail.ch
:revnumber: 75
:revdate: 2019.09.03
:revremark: Remove 'we' and 'our' from the text
:doctype: article
// Visual
:toc:
// Subs:
:hs: #
:dhs: ##
:us: _
:dus: __
:as: *
:das: **

++++
<p align="center">
<em>Bash framework for dotfiles and everything Bash</em>
</p>
++++

[#divine-dotfiles-plaque]
image::lib/img/divine-dotfiles-plaque.png[Divine.dotfiles,align="center"]

New machine or new OS?
Set it up with a single `*di install --yes*`.

[.note]
[%noheader,cols="<.<a"]
|===
| `di` stands for **d**ivine **i**ntervention.
|===

_Divine.dotfiles_ encourages treating Bash scripts as *deployments* — portable packages that are (un)installed via the neat command line interface.

== In a nutshell

[.note]
[%noheader,cols="<.<a"]
|===
| First time users are welcome to take a <<joy-ride,joy ride>> for a quick tour de force.
|===

_Divine.dotfiles_ leverages *deployments*.

A deployment is a Bash script with three specially named functions: one to check, another to install, third to remove.
Return codes are used to communicate status back to the framework.
As such, authoring a deployment is akin to implementing an interface.

The goals of _Divine.dotfiles_ are:

* *Automation* of setting-up any machine that runs Bash.
+
The <<intervention-utility,intervention utility `di`>> is a practical tool for handling any number of deployments.
* *Cross-platformness* within Unix-like world.
+
Built-in OS detection mechanisms facilitate writing portable deployments.
* Promotion of *standards* and *best practices*.
+
Deployment ecosystem is designed with distribution and pluggability in mind.

<<divine-deployments,*Divine deployments*>> (distributed separately) strive to exemplify what a good deployment should look like.

=== Example deployment

Say, you install the same command line utility on every machine.
Here's a sample deployment that does a scaled down version of that:

[source,bash,subs="verbatim,attributes"]
----
# grail/dpls/example.dpl.sh

d_dpl_check() {
  [ -e ~/bin/cmd ] && return 1 {vbar}{vbar} return 2
}

d_dpl_install() {
  cat >~/bin/cmd <<<'echo Divine.dotfiles rocks' && chmod +x ~/bin/cmd
}

d_dpl_remove() {
  rm -f -- ~/bin/cmd
}
----

And here is what working with it looks like:

[#divine-dotfiles-example-1]
image::lib/img/divine-dotfiles-example-1.gif[Divine.dotfiles example 1,align="center"]

Dead simple, right?
You wouldn’t need a framework for that.
But wait, there’s [.small]#_(hopefully)_# more.

=== Framework features

.Framework features
[%noheader,cols="<.<a",stripes=none]
|===

| +++<p align="center">+++<<divinefiles,*Divinefile*>>+++</p>+++

Special deployment that maintains a stable set of system packages across machines and OS's.

| +++<p align="center">+++<<grail-directory,*The Grail directory*>>+++</p>+++

Store your deployments and assets (e.g., personal config files) in one place.
On a new machine — <<plug-routine,plug in>> your Grail [.small]#_(heh)_# from a repo or a local dir with one command.

| +++<p align="center">+++<<deployment-priority,*Priorities*>>+++</p>+++

Easily marshal your deployments in order, which is automatically reversed for uninstallation.

| +++<p align="center">+++<<deployment-groups,*Groups*>>+++</p>+++

Split your deployment collection into groups to easily handle selective installations.

| +++<p align="center">+++<<detected-os,*Cross-platformness*>>+++</p>+++

Use built-in OS detection mechanism to perform certain tasks on certain distributions or OS families.

| +++<p align="center">+++<<attach-routine,*Third-party deployments (bundles)*>>+++</p>+++

Attach pre-made bundles of deployments from Github (such as the glorious https://github.com/no-simpler/divine-bundle-essentials[`essentials`] bundle).

| +++<p align="center">+++<<stash,*Stash*>>+++</p>+++

Persistent key-value store for use within your deployments.

| +++<p align="center">+++<<assets,*Assets*>>+++</p>+++

Easily separate your deployments into static logic and dynamic content.

| +++<p align="center">+++<<generic-queue,*Queues*>> and <<multitask,*multitask*>>+++</p>+++

Delegate to built-in mechanisms for deployments that perform a series of tasks.

|===

== Installing and uninstalling the framework

=== System requirements

* https://en.wikipedia.org/wiki/Unix-like[Unix-like OS].
Following OS distributions are openly supported:
+
--
** *Debian*
** *Fedora*
** *FreeBSD*
** *macOS*
** *Ubuntu*
--
+
[.note]
[%noheader,cols="<.<a"]
|===
| This list is incomplete; you can help by <<contributing-os-support,expanding it>>.
|===
+
The framework will work on other operating systems too, but without support for automatic installation of system packages (e.g., <<divinefiles,Divinefiles>> will not work).

* `bash 3.2+` and either `curl` or `wget`
+
[.note]
[%noheader,cols="<.<a"]
|===
| `git` is not a hard requirement, but it is not flaccid either.
You can install _Divine.dotfiles_ without `git`.
But then the framework will bug you with suggestions to auto-install it until you relent.
|===

=== Installing the framework

To install _Divine.dotfiles_ framework, run the following single command in Terminal:

[source,bash]
----
bash -c 'TMP=$(mktemp); URL=https://raw.github.com/no-simpler/divine-dotfiles/master/lib/install/install.sh; if curl --version &>/dev/null; then curl -fsSL $URL >$TMP; elif wget --version &>/dev/null; then wget -qO $TMP $URL; else printf >&2 "\n==> Error: failed to detect neither curl nor wget\n"; rm -f $TMP; exit 1; fi || { printf >&2 "\n==> Error: failed to download installation script\n"; rm -f $TMP; exit 2; }; chmod +x $TMP && $TMP "$@"; RC=$?; rm -f $TMP; ((RC)) && exit 3 || exit 0' bash
----

[.note]
[%noheader,cols="<.<a"]
|===
| Installation is completely safe:

* No files are overwritten.
* This repository is cloned/downloaded.
* One symlink is (optionally) created.

Oh, and you will be prompted for everything.
|===

==== Installation options and overrides

Add flavoring to your installation as such:

.Framework installation options and overrides
[%noheader,cols="<.<a",stripes=none]
|===

^.^h| Prepend on the left

| `*D_FMWK_DIR=_DIRPATH_*`

Install framework within `*_DIRPATH_*` instead of default `~/.divine/`

| `*D_SHORTCUT_NAME=_CMD_*`

Name shortcut shell command `*_CMD_*` instead of default `di`

| `*D_SHORTCUT_DIR=_DIRPATH_*`

Install shortcut shell command within `*_DIRPATH_*` instead of the default way: choosing among directories on `$PATH`

^.^h| Append on the right

| `*--yes*`

Install everything without prompts

| `*--no*`

Install absolutely nothing

| `*--framework-yes*`

Install framework without prompt

| `*--framework-no*`

Install absolutely nothing (synonym of `--no`)

| `*--shortcut-yes*`

Install shortcut shell command without prompt

| `*--shortcut-no*`

Skip installing shortcut shell command

| `*--verbose*`

Increase amount of output

| `*--quiet*`

[.gray]##_(default)_## Decrease amount of output

|===

=== Uninstalling the framework

To uninstall _Divine.dotfiles_ framework, run the following single command in Terminal:

[source,bash]
----
bash -c 'TMP=$(mktemp); URL=https://raw.github.com/no-simpler/divine-dotfiles/master/lib/uninstall/uninstall.sh; if curl --version &>/dev/null; then curl -fsSL $URL >$TMP; elif wget --version &>/dev/null; then wget -qO $TMP $URL; else printf >&2 "\n==> Error: failed to detect neither curl nor wget\n"; rm -f $TMP; exit 1; fi || { printf >&2 "\n==> Error: failed to download uninstallation script\n"; rm -f $TMP; exit 2; }; chmod +x $TMP && $TMP "$@"; RC=$?; rm -f $TMP; ((RC)) && exit 3 || exit 0' bash
----

Uninstallation removes optional dependencies that might have been installed, and then erases framework directory.

One thing it does *_not_* do is uninstall deployments.
*_You have to uninstall your deployments manually!_*

By default, a copy of your usage files (including <<grail-directory,the Grail>>) is retained, so even if you forget to uninstall deployments, there is potentially a way to remedy that.

==== Uninstallation options and overrides

Add flavoring to your uninstallation as such:

.Framework uninstallation options and overrides
[%noheader,cols="<.<a",stripes=none]
|===

^.^h| Prepend on the left

| `*D_FMWK_DIR=_DIRPATH_*`

Uninstall framework within `*_DIRPATH_*` instead of default `~/.divine/`

^.^h| Append on the right

| `*--yes*`

Uninstall everything without prompts

| `*--no*`

Uninstall absolutely nothing

| `*--utils-yes*`

Uninstall system packages installed by the framework (e.g., `git`) without prompt

| `*--utils-no*`

Skip uninstalling system packages installed by the framework (e.g., `git`)

| `*--backup-yes*`

[.gray]##_(default)_## Make backup of usage files (including Grail dir) without prompt

| `*--backup-no*`

Skip backing up usage files (including Grail dir)

| `*--framework-yes*`

Erase framework directory without prompt

| `*--framework-no*`

Uninstall absolutely nothing (synonym of `--no`)

| `*--verbose*`

Increase amount of output

| `*--quiet*`

[.gray]##_(default)_## Decrease amount of output

|===

[[joy-ride]]
=== Joy ride

First timer?
Looking for a feel of what _Divine.dotfiles_ offers?
Here’s a safe and fully removable way to acquaint yourself with the framework:

[source,bash]
----
bash -c 'TMP=$(mktemp); URL=https://raw.github.com/no-simpler/divine-dotfiles/master/lib/install/install.sh; if curl --version &>/dev/null; then curl -fsSL $URL >$TMP; elif wget --version &>/dev/null; then wget -qO $TMP $URL; else printf >&2 "\n==> Error: failed to detect neither curl nor wget\n"; rm -f $TMP; exit 1; fi || { printf >&2 "\n==> Error: failed to download installation script\n"; rm -f $TMP; exit 2; }; chmod +x $TMP && $TMP "$@"; RC=$?; rm -f $TMP; ((RC)) && exit 3 || exit 0' bash --yes \
&& ~/.divine/intervene.sh attach essentials --yes \
&& ~/.divine/intervene.sh install --yes
----

This command: installs the framework without prompts; attaches the https://github.com/no-simpler/divine-bundle-essentials[`essentials`] bundle of Divine deployments to your Grail directory; installs the deployments.

Divine deployments *_never overwrite_* pre-existing files on your system without backing them up.
Everything that is backed up is *_automatically restored_* upon uninstallation.

After all installations are successful, *reload your shell/terminal*.
(On macOS, if the default shell has been changed, you have to re-log into the system.)

==== What it does

Once the bundle is fully installed, and the shell reloaded, _voilà_:

* You are greeted by https://sourceforge.net/projects/zsh[Zsh] as the default shell.
* Basic necessities, such as https://git-scm.com[Git], https://www.vim.org[Vim], and https://gnupg.org[GnuPG] are available.
* Both https://ohmyz.sh[oh-my-zsh] and https://github.com/Bash-it/bash-it[Bash-it] frameworks are now installed and loaded.
* A minimalistic theme for both shell frameworks is active.
* Opinionated configs are plugged in for Git, Vim, Bash, and Zsh.
* Overwritten files and installations are safely backed up or re-used.

All of the above is controlled and customized from your <<grail-directory,Grail directory>>:

[source]
----
~/.divine/grail/assets/
----

.Description of asset directories for the bundle `essentials`
[%noheader,cols="<.<a,<.<a",stripes=none]
|===

| `*bash-it*/` *&dagger;*
| Custom assets for https://github.com/Bash-it/bash-it[Bash-it] shell framework

| `*brewfile*/` *&dagger;*
| https://github.com/Homebrew/homebrew-bundle[Brewfile], maintained on macOS

| `*config-git*/`
| Global configuration for Git

| `*config-shell*/`
| Startup scripts (https://en.wikipedia.org/wiki/Run_commands[runcoms]) for Bash and Zsh

| `*config-vim*/`
| Global configuration for Vim

| `*home-dirs*/` *&dagger;*
| File `*home-dirs.cfg*` defines a sub-directory tree, to be maintained under the home directory

| `*oh-my-zsh*/` *&dagger;*
| Custom assets for https://ohmyz.sh[oh-my-zsh] shell framework

| `*portable-bin*/`
| Portable container for personal executables; this directory is maintained on the `$PATH`

|===

[.note]
[%noheader,cols="<.<a"]
|===
| Dagger *&dagger;* mark meaning: in order for the modifications in that asset directory to take effect, the deployment must be (re-)installed.
|===

==== Cleaning up

Yes, all of the above is fully removable.
Below are the separate 'undo' steps, in order:

[source,bash]
----
# Uninstall deployments:
~/.divine/intervene.sh remove --yes

# Detach Divine deployments from your Grail directory:
~/.divine/intervene.sh detach essentials --yes

# Erase the framework without keeping backups:
bash -c 'TMP=$(mktemp); URL=https://raw.github.com/no-simpler/divine-dotfiles/master/lib/uninstall/uninstall.sh; if curl --version &>/dev/null; then curl -fsSL $URL >$TMP; elif wget --version &>/dev/null; then wget -qO $TMP $URL; else printf >&2 "\n==> Error: failed to detect neither curl nor wget\n"; rm -f $TMP; exit 1; fi || { printf >&2 "\n==> Error: failed to download uninstallation script\n"; rm -f $TMP; exit 2; }; chmod +x $TMP && $TMP "$@"; RC=$?; rm -f $TMP; ((RC)) && exit 3 || exit 0' bash --yes --backup-no
----

After the three 'undo' steps have successfully run, there is no trace of _Divine.dotfiles_ on your system.
[.small]#_(Sigh.)_#

== Framework structure

_Divine.dotfiles_ is installed, by default, to `~/.divine/`, and is contained entirely in that directory, except:

* Symlink to the framework's main executable is created somewhere on `$PATH`.
* Deployments may affect your system pretty much anywhere.

The framework itself consists of the following main parts:

.Framework structure
[%noheader,cols="<.<a",stripes=none]
|===

| +++<p align="center">+++[#grail-directory]#`~/.divine/*grail*/`#+++</p>+++

*The Grail directory* houses user’s deployments, assets, and persistent settings.

If you settle on using _Divine.dotfiles_, it is recommended to take your Grail directory under version control and syncing it, e.g., via cloud services or Github.

Sub-structured as follows:

* `*assets*/` — Directory for user's assets, such as config files.
* `*dpls*/` — Directory for user's deployments.
* `*.stash.cfg*` — _Grail <<stash,stash>> entries maintained by the framework._
* `*.stash.cfg.md5*` — _Grail <<stash,stash>> integrity checksum maintained by the framework._

| +++<p align="center">+++[#state-directory]#`~/.divine/*state*/`#+++</p>+++

*The state directory* stores data on the current state of deployments on current machine.
_(Entire directory is maintained by the framework.)_

Sub-structured as follows:

* `*backups*/` — _Divine.dotfiles_ provides facilities to back up existing files from the system.
This directory stores such backups.
* `*bundles*/` — _Divine.dotfiles_ provides facilities to <<attach-routine,attach third-party bundles of deployments>> from Github.
This directory stores such deployments.
* `*stash*/` — _Divine.dotfiles_ provides a <<stash,persistent key-value store>> for use within deployments.
This directory houses key-value containers.

| +++<p align="center">+++[#lib-directory]#`~/.divine/*lib*/`#+++</p>+++

Guts of the framework, structured to the best of creator's ability.
_(Entire directory is, naturally, maintained by the framework.)_

| +++<p align="center">+++`~/.divine/*intervene.sh*`+++</p>+++

<<intervention-utility,*Divine intervention utility*>>, the command line interface to the framework.
_(File is maintained by the framework.)_

| +++<p align="center">+++`<a directory on $PATH>/*di*`+++</p>+++

Symlink to the intervention utility, providing an easy access.
This symlink is usually automatically created during framework installation.

|===

== Usage

[[intervention-utility]]
=== Divine intervention utility `di`

_Divine.dotfiles_ provides a command line interface via *Divine intervention utility `di`*.

Intervention utility's functions are:

. <<primary-routines,*Primary routines*>> on <<deployments,deployments>> and <<divinefiles,Divinefiles>>:
.. *Check* whether deployments are installed or not.
.. *Install* deployments.
.. *Uninstall* deployments.
. <<attach-routine,*Attach/detach*>> third-party bundles of deployments from Github.
. <<plug-routine,*Plug in*>> pre-made Grail directory from a repository or local directory.
. <<update-routine,*Update*>> framework itself, attached bundles, and Grail directory, if it is a cloned repository.

[.note]
[%noheader,cols="<.<a"]
|===
| The term '<<deployments,deployments>>' includes <<divinefiles,Divinefiles>> as the special kind of the former.
|===

[[primary-routines]]
=== Checking/installing/removing deployments

Primary routines — the core of the framework — launch respective functions on deployments.

[source,subs="verbatim,quotes,attributes"]
----
$ *di* *c*[*heck*]    [-ynqvew]  [-b *_BUNDLE_*]… [--] [*_NAME_*]…

$ *di* *i*[*nstall*]  [-ynqvewf] [-b *_BUNDLE_*]… [--] [*_NAME_*]…

$ *di* *r*[*emove*]   [-ynqvewf] [-b *_BUNDLE_*]… [--] [*_NAME_*]…
----

Accepted values of `*_NAME_*` are (case-insensitive):

* Names of <<deployments,deployments>>.
* Reserved synonyms for <<divinefiles,Divinefiles>>: `divinefile`, `dfile`, `df`.
* Single-digit names of <<deployment-groups,deployment groups>>: `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`.

==== Filtering deployments

The intervention utility filters the deployments according to these rules:

* Without any arguments, all deployments are processed.
* By default, deployments are retrieved from two locations (at any depth):
** Directory for user's deployments: `grail/dpls/`.
** Directory for attached bundles of deployments: `state/bundles/`.
* Particular bundles of deployments are requested by listing them with the `--bundle`/`-b` option.
* Particular deployments are requested by listing their names or <<deployment-groups,single-digit group names>>, in any combination.
* <<dangerous-deployments,Dangerous>> deployments are ignored unless requested by name (not by single-digit group name), or unless `--with-!`/`-w` option is used.
* Option `--except`/`-e` inverts filtering: all deployments are processed, _except_ those listed.
Note, that without any arguments, this is a no-opt.
+
In this mode, dangerous deployments are still filtered out by default.

After filtering, deployments and packages from Divinefiles are sorted in order of ascending <<deployment-priority,priority>>.
For uninstallation, that order is fully reversed.

==== Primary routine options

.Primary routine options
[%noheader,cols="<.<a",stripes=none]
|===

| `*-y*`, `*--yes*`

Normally, framework prompts user right before sourcing each deployment script.
Other events — like offering an optional framework dependency — also trigger a prompt.

With this option, affirmative answer is assumed to every non-<<urgent-prompt,urgent>> prompt.

Note, that deployments are free to add any number of custom prompts unaffected by this option.

Access within deployments: `$D__OPT_ANSWER` (`true` / `false` / _empty_).

| `*-n*`, `*--no*`

With this option, negatory answer is assumed to every built-it prompt.
This option is equivalent to a 'dry run' — apart from skip messages, nothing will actually be done.

Access within deployments: `$D__OPT_ANSWER` (`true` / `false` / _empty_).

| [#bundle-option]#`*-b* *_BUNDLE_*`, `*--bundle* *_BUNDLE_*`#

[.gray]##_(repeatable)_## If at least one such option is provided, the search for deployments will be limited to the given <<attach-routine,attached bundles>> of deployments.
Accepted values of `*_BUNDLE_*` are the same as the <<accepted-repo-values,accepted values of `*_REPO_*`>> during attaching of bundles.

| `*-f*`, `*--force*`

By default, the framework does *not*:

* re-install deployments that appear already installed;
* uninstall deployments that appear already not installed;
* process deployments that appear installed by means other than this framework.

This option overrules such considerations.

Access within deployments: `$D__OPT_FORCE` (`true` / `false`).

| `*-e*`, `*--except*`

This option inverts the behavior of deployment filter: instead of processing only listed deployments, all deployments are processed _except_ listed.

Access within deployments: `$D__OPT_INVERSE` (`true` / `false`).

| `*-w*`, `*--with-!*`

By default framework ignores <<dangerous-deployments,dangerous deployments>> unless they are named explicitly.
This option disables such behavior.

Access within deployments: `$D__OPT_EXCLAM` (`true` / `false`).

| `*-v*`, `*--verbose*`

Increase amount of output

Access within deployments: `$D__OPT_QUIET` (`true` / `false`).

| `*-q*`, `*--quiet*`

[.gray]##_(default)_## Decrease amount of output

Access within deployments: `$D__OPT_QUIET` (`true` / `false`).

|===

[.note]
[%noheader,cols="<.<a"]
|===
| Even though every option above serves a function within the framework, it is also up to deployment authors to honor their semantics.
|===

[[attach-routine]]
=== Attaching third-party deployments

Beside using own deployments, _Divine.dotfiles_ allows you to attach (i.e., import) third-party *bundles* of deployments distributed via Github repositories.
A bundle is understood to group together one or more deployments.

[source,subs="verbatim,quotes,attributes"]
----
$ *di* *a*[*ttach*] [-yn] [--] *_REPO_*…

$ *di* *d*[*etach*] [-yn] [--] *_REPO_*…
----

[#accepted-repo-values]#Accepted values of `*_REPO_*`# are (case-insensitive):

* Github repository in the form: `no-simpler/divine-bundle-essentials`.
* Specifically for Divine deployments, a shorthand is accepted:
+
[source,subs="verbatim,quotes,attributes"]
----
`*_NAME_*`  =>  `no-simpler/divine-bundle-*_NAME_*`
----
+
(To be a shorthand, `*_NAME_*` must match the RegEx pattern `^[0-9A-Za-z_.-]+$`.)

Detaching deployments deletes the copy of their repository, but it is up to you to:

* Uninstall the deployments beforehand (re-attach if you forgot).
* Remove any assets that might have been copied into your <<grail-directory,Grail>> assets directory.

[.note]
[%noheader,cols="<.<a"]
|===
| Attached bundles are cloned/downloaded into your <<state-directory,state directory>>, but _attachment records_ are stored in <<grail-directory,the Grail>>.
On every launch, intervention utility synchronizes Grail records with actual repositories in state directory.

Thus, by synchronizing Grail between machines, you will have the same set of both personal and attached deployments everywhere.
|===

==== Attach/detach routine options

.Attach/detach routine options
[%noheader,cols="<.<a",stripes=none]
|===

| `*-y*`, `*--yes*`

Normally, framework prompts user right before cloning/downloading repository.
Other events — like offering an optional framework dependency — also trigger a prompt.

With this option, affirmative answer is assumed to every built-it prompt.

| `*-n*`, `*--no*`

With this option, negatory answer is assumed to every built-it prompt.
This option is equivalent to a 'dry run' — apart from skip messages, nothing will actually be done.

|===

[[plug-routine]]
=== Plugging the Grail

If you have a copy of your carefully crafted <<grail-directory,Grail directory>> stored somewhere, _Divine.dotfiles_ lets you easily plug it in.

[source,subs="verbatim,quotes,attributes"]
----
$ *di* *p*[*lug*] [-ynl] [--] *_ADDRESS_*
----

Accepted values of `*_ADDRESS_*` are:

* Github repository in the form: `username/repo-name`.
* Path to a generic git repository.
* Path to a local directory.

Repositories are cloned, directories are copied.
Note, that existing Grail directory will be utterly destroyed in the process.

If provided argument can be interpreted in multiple ways, the framework will iterate over possible options in the order they are given above.

==== Plug routine options

.Plug routine options
[%noheader,cols="<.<a",stripes=none]
|===

| `*-y*`, `*--yes*`

Normally, framework prompts user right before overwriting existing Grail directory.
Other events — like offering an optional framework dependency — also trigger a prompt.

With this option, affirmative answer is assumed to every built-it prompt.

If provided argument can be interpreted in multiple ways, the first viable interpretation will be silently settled upon.

| `*-n*`, `*--no*`

With this option, negatory answer is assumed to every built-it prompt.
This option is equivalent to a 'dry run' — apart from skip messages, nothing will actually be done.

| `*-l*`, `*--link*`

With this option, symlink is created to the directory, path to which is given, instead of copying it.
In this mode, given argument is not considered as a repository.

|===

[[update-routine]]
=== Updating framework and deployments

[source,subs="verbatim,quotes,attributes"]
----
$ *di* *u*[*pdate*] [-yn] [--] [*f*[*ramework*]] [*g*[*rail*]] [*d*[*eployments*]]
----

Update routine is three-pronged, and you are free to engage any and all of the prongs:

* `*f*` or `*framework*` — pulls latest revision of _Divine.dotfiles_.
* `*g*` or `*grail*` — pulls latest revision of <<grail-directory,Grail directory>>, _if_ it is a <<plug-routine,plugged>> repository.
* `*d*` or `*deployments*` — pulls latest revision of every <<attach-routine,_attached_>> bundle of deployments.
* Without any arguments, all of the above are performed.

==== Updating routine options

.Updating routine options
[%noheader,cols="<.<a",stripes=none]
|===

| `*-y*`, `*--yes*`

Normally, framework prompts user right before pulling from remote repository.
Other events — like offering an optional framework dependency — also trigger a prompt.

With this option, affirmative answer is assumed to every built-it prompt.

| `*-n*`, `*--no*`

With this option, negatory answer is assumed to every built-it prompt.
This option is equivalent to a 'dry run' — apart from skip messages, nothing will actually be done.

|===

[[deployments]]
== Deployments

A _Divine.dotfiles_ *deployment* is a Bash script named in `*_DPL-NAME_*.dpl.sh` pattern.
`*_DPL_NAME_*` must be non-empty.

To be picked up by the framework, deployments must be located at any depth under two recognized deployment directories:

* `grail/dpls/` — user's deployments.
Create your deployments here.
* `state/bundles/` — attached third-party bundles of deployments.
This one is maintained by the framework.

=== Deployment structure

The minimal valid deployment is an empty file.
As such, it does nothing but appear in framework output.

Deployments are written in Bash syntax (with some limitations on metadata).
Each deployment is sourced by Bash interpreter no more than once per intervention routine.

A deployment is formed by:

* implementing specially named Bash functions (<<primary-functions,*primaries*>>);
* assigning to specially named variables (<<deployment-metadata,*metadata*>>).

[[primary-functions]]
=== Primary functions

*Primary functions*, or *primaries*, correspond to three fundamental actions performed upon a deployment:

* `d_dpl_check()` — checks whether deployment is installed or not.
* `d_dpl_install()` — installs deployment.
* `d_dpl_remove()` — uninstalls (reverses previous installation of) deployment.

This section includes semantic meanings behind primaries and their return codes.
Feel free to stretch semantic guidelines according to your particular use case.

[[func-dpl-check]]
==== Primary function `d_dpl_check()`

If this function is implemented, it will be called:

* During `check` routine — to determine status and show relevant output.
* During `install` routine — to determine whether installation is necessary/possible.
* During `remove` routine — to determine whether uninstallation is necessary/possible.

Return code of `d_dpl_check()` determines current status of the deployment:

.Supported return codes of `d_dpl_check()`
[%noheader,cols="<.<a",stripes=none]
|===

| `*0*`: *Unknown*

Meaning: no reliable way to tell whether this deployment is installed or not.

_This return code is assumed if `d_dpl_check()` is not implemented or if unsupported code is returned._

Routines that will proceed further:

* `install`
* `remove`

| `*1*`: *Installed*

Meaning: as it stands, intended goal of installing this deployment is entirely achieved.

Routines that will proceed further:

* `remove`

| `*2*`: *Not installed*

Meaning: as it stands, intended goal of installing this deployment is entirely not achieved.

Routines that will proceed further:

* `install`

| `*3*`: *Irrelevant*

Meaning: processing this deployment in current environment does not make sense.

This code is appropriate, for example, if current OS is unsupported.

None of the routines will proceed further.

| `*4*`: *Partly installed*

Meaning: as it stands, intended goal of installing this deployment is partly achieved and partly not achieved.

This code differs from 'Unknown' in semantics and output styling.

Routines that will proceed further:

* `install`
* `remove`

|===

[[func-dpl-install]]
==== Primary function `d_dpl_install()`

If this function is implemented, it will be called during `install` routine — to achieve the intended goal of this deployment.

Return code of `d_dpl_install()` determines output of `install` routine:

.Supported return codes of `d_dpl_install()`
[%noheader,cols="<.<a",stripes=none]
|===

| `*0*`: *Successfully installed*

Meaning: intended goal of installing this deployment is entirely achieved.

_This return code is assumed if `d_dpl_install()` is not implemented or if unsupported code is returned._

| `*1*`: *Failed to install*

Meaning: intended goal of installing this deployment is _not entirely_ achieved due to error.

| `*2*`: *Skipped*

Meaning: intended goal of installing this deployment is _entirely not_ achieved because nothing has been done.

| `*100*`: *Reboot needed*

Meaning: same as 'Successfully installed', except:

* Intervention will gracefully shut down without moving past this deployment.
* User will be asked to reboot the machine and resume afterward.

| `*101*`: *User attention needed*

Meaning: same as 'Successfully installed', except:

* Intervention will gracefully shut down without moving past this deployment.
* Deployment is expected to print explanation to `stderr`.

| `*102*`: *Critical failure*

Meaning: same as 'Failed to install', except:

* Intervention will shut down without moving past this deployment.
* Output will mention critical failure.

|===

[[func-dpl-remove]]
==== Primary function `d_dpl_remove()`

If this function is implemented, it will be called during `remove` routine — to reverse the effects of previously installing this deployment.

Return code of `d_dpl_remove()` determines output of `remove` routine:

.Supported return codes of `d_dpl_remove()`
[%noheader,cols="<.<a",stripes=none]
|===

| `*0*`: *Successfully uninstalled*

Meaning: effects of previously installing this deployment are entirely reversed.

_This return code is assumed if `d_dpl_remove()` is not implemented or if unsupported code is returned._

| `*1*`: *Failed to uninstall*

Meaning: effects of previously installing this deployment are _not entirely_ reversed due to error.

| `*2*`: *Skipped*

Meaning: effects of previously installing this deployment are _entirely not_ reversed because nothing has been done.

| `*100*`: *Reboot needed*

Meaning: same as 'Successfully uninstalled', except:

* Intervention will gracefully shut down without moving past this deployment.
* User will be asked to reboot the machine and resume afterward.

| `*101*`: *User attention needed*

Meaning: same as 'Successfully uninstalled', except:

* Intervention will gracefully shut down without moving past this deployment.
* Deployment is expected to print explanation to `stderr`.

| `*102*`: *Critical failure*

Meaning: same as uninstall', excep:

* Intervention will shut down without moving past this deployment.
* Output will mention critical failure.

|===

[.note]
[%noheader,cols="<.<a"]
|===
| It is worth noting that intended semantics of uninstallation are not direct inverse to that of installation.
Ideally, if no installation via the framework has previously occurred, uninstallation should do nothing.

This philosophy is followed by the magnificent https://github.com/no-simpler/divine-bundle-essentials[`essentials`] bundle of Divine deployments.
|===

[[deployment-metadata]]
=== Deployment metadata

*Deployment metadata* (posing as variable assignments) alter deployment's appearance and behavior:

* <<deployment-name-and-desc,`D_DPL_NAME`>> — explicit name for the deployment.
* <<deployment-name-and-desc,`D_DPL_DESC`>> — one-line description of the deployment.
* <<deployment-priority,`D_DPL_PRIORITY`>> — priority of the deployment (non-negative integer).
* <<deployment-flags,`D_DPL_FLAGS`>> — one-character flags, causing special treatment.
* <<deployment-warning,`D_DPL_WARNING`>> — one-line cautionary message about this deployment.

[.note]
[%noheader,cols="<.<a"]
|===
| Although all deployment metadata look like Bash variable assignments, they are in fact extracted from the file _before_ it is interpreted by Bash.

For each reserved 'variable' name, first line that looks like the usual Bash assignment is used.

With that in mind, follow these simple rules for deployment metadata:

* Write one 'assignment' per line, without line continuation.
* Do not use Bash substitutions or comments.
* Avoid leading and trailing whitespace, as well as whitespace around the `=`.
* Matching quotes around the value are allowed (they are stripped in the processing).
|===

[[deployment-name-and-desc]]
==== Deployment name and description

[source,bash]
----
D_DPL_NAME=example
D_DPL_DESC='Simple description that shows in deployment prompts'
----

While *description* is mostly cosmetic, deployment *name* is very important.
It is the single unique identifier for every deployment, and is used to invoke primary routines on it.
As such, the framework forbids having more than one deployment sharing a name.

If deployment name is not provided explicitly, file name is used instead, sans `.dpl.sh` suffix.
Deployment names are case insensitive.

[[deployment-priority]]
==== Deployment priority

[source,bash]
----
D_DPL_PRIORITY=420
----

Priority is the way to impose order on deployment processing.

During `check` and `install` routines, deployments are sorted in ascending order (smaller integer values go first).
During `uninstall` routine, the order is fully reversed.
Order of deployments with the same priority is undefined.

Priority must be a non-negative integer, otherwise it falls back to the default value of `4096`.

[[deployment-flags]]
==== Deployment flags

[source,bash]
----
D_DPL_FLAGS=ci!89
----

Flags alter some of the framework's behavior toward the deployment.

* A flag is a single non-whitespace character.
* Any number of flags can be put together in any order.
* Repeating a flag does not bear any additional significance.
* There is no way to unset a flag, apart from not setting it.
* Unsupported flags are silently ignored.

Below is the exhaustive rundown of supported flags and their effects.

.List of supported deployment flags
[%noheader,cols="<.<a",stripes=none]
|===

| [#deployment-groups]#`*[0-9]*`# _(any single digit)_

Assigns the deployment to one of the ten single-digit *groups*.
Groups of deployments may be processed together by referring to them by that group's digit in place of deployment name.

[.note]
[%noheader,cols="<.<a"]
!===
! A deployment may not have a single-digit name.
The framework guards against using reserved words as deployment names.
!===

| [#dangerous-deployments]#`*!*`# _(an exclamation mark)_

Marks the deployment as *dangerous*.
By default, framework ignores dangerous deployments unless they are listed by name or by name of their group.
Another way to include dangerous deployments is the `--with-!`/`-w` option on intervention utility.

| [#urgent-prompt]#`*[cira]*`# _(any of the four lowercase letters)_

Intervention utility has the `--yes`/`-y` option that effectively skips all normal prompts and confirmations.
It is possible to force the appearance of an *urgent prompt* before the deployment is sourced regardless of said option.
To do so, use any of these flags:

* `*c*` — always prompt during `**c**heck` routine.
* `*i*` — always prompt during `**i**nstall` routine.
* `*r*` — always prompt during `**r**emove` routine.
* `*a*` — **a**ll of the avove.

When a prompt is forced by a flag, it remains urgent even without `--yes` option.
Urgent prompts are styled to stand out a bit more in terminal.

|===

[[deployment-warning]]
==== Deployment warning

[source,bash]
----
D_DPL_WARNING="Warning for 'urgent' prompts forced by a flag"
----

If such warning is provided, it will accompany every <<urgent-prompt,urgent>> prompt enforced by a deployment flag.

[[divinefiles]]
== Divinefiles

A *Divinefile* is a special kind of deployment.
Its purpose is akin to that of https://github.com/Homebrew/homebrew-bundle[Brewfile] or https://bundler.io/gemfile.html[Gemfile].
A Divinefile is a manifest of system packages to be maintained using supported system package managers.

* A Divinefile must be named, well, `Divinefile`.
* There can absolutely be more than one — their contents are effectively merged.
* The framework picks up every Divinefile located at any depth under two recognized deployment directories:
** `grail/dpls/` — user's Divinefiles. Create yours here.
** `state/bundles/` — attached third-party Divinefiles.
* Divinefiles collectively are a deployment.

=== Divinefile usage

Divinefiles are automatically picked up by the framework along with other deployments.

Divinefiles are referred to with synonyms: `divinefile`, `dfile`, or `df`.
As with all deployment names, these are case insensitive.
Divinefiles are processed in their merged entirety or not processed at all.

[.note]
[%noheader,cols="<.<a"]
|===
| Yes, you also cannot name regular deployments `divinefile`, `dfile`, or `df`.
The framework guards against using reserved words as deployment names.
|===

You can assign deployment-style <<deployment-priority,*priorities*>> and <<deployment-flags,*flags*>> to individual packages within Divinefiles.
Packages are intertwined with regular deployments in a shared workflow.

[.note]
[%noheader,cols="<.<a"]
|===
| For more complex system package installations, e.g., involving particular versions or special package manager options, use regular deployments.
|===

=== Divinefile syntax

Divinefiles follow the general <<manifest-syntax,manifest syntax>>.

Every entry is a *list* of whitespace-separated names of packages.
Keys `flags` and `priority` set the respective attributes for the packages, and work identically to <<deployment-flags,flags>> and <<deployment-priority,priority>> in regular deployments.

Within a line, each vertical bar `|` starts an *alt-list*, which fully overrides the original list for a particular package manager.
Within an alt-list, everything to the left of first colon `:` is read as package manager name; everything to the right — as the alt-list itself.

[.note]
[%noheader,cols="<.<a"]
|===
| Package manager name is matched against <<var-os-pkgmgr,`$D__OS_PKGMGR`>> built-in variable.
|===

.Example of Divinefile
[source]
----
git vim                 # Maintain git and vim with default priority (4096)


(priority:300)          # Set priority to 300 henceforth


(priority:500)  \       # Set priority to 500 for this line only
(r)             \       # Set flag 'prompt before removing' for this line only
node            \       # Maintain node
| apt-get: nodejs npm   # On apt-get, maintain nodejs and npm instead


(os:fedora) \           # Make this line exclusive to Fedora
util-linux-user         # Maintain util-linux-user with priority 300
----

== Advanced features

_Divine.dotfiles_ offers mechanisms that facilitate creation of better, stronger, faster deployments.

=== Deployment guidelines

A deployment file is interpreted by Bash no more than once per intervention.
Sourcing occurs as late as possible, after exhausting excuses to skip it.

A subshell is created for every deployment, shielding other deployments from it.

[.note]
[%noheader,cols="<.<a"]
|===
| Naturally, there is no way to prevent deployments from negatively affecting your system.
Deployments are free-form Bash scripts, and sandboxing them beyond a subshell would defeat their purpose.

If there is a voice of wisdom here, it says, 'Be careful.'
|===

It is good style to isolate all deployment logic within functions and global variables, and then call/use them within <<primary-functions,primary functions>>.

==== Naming convention

_Divine.dotfiles_ uses a naming convention in its own code:

* `*D_*` prefix — for names of global variables;
* `*d_*` prefix — for names of functions.

Whenever the framework does _not_ expect you to reassign a global variable or re-implement a function, the underscore is doubled:

* `*D__*` prefix — for names of read-only internal variables;
* `*d__*` prefix — for names of call-only internal functions.

[.note]
[%noheader,cols="<.<a"]
|===
| Some of the most used framework functions have grown so attached to their `d` prefix, that they omit the underscores altogether.
Examples are: `dprint_*` family of functions, `dprompt`, `dstash`, `dln`, `dcp`, etc.

All such functions are call-only, i.e., *not* for re-implementation.
|===

=== Variables available to deployments

.List of variables available/recognized in each deployment
[%noheader,cols="<.<a",stripes=none]
|===

^.^h| <<deployment-metadata,Deployment metadata>>

| `*D_DPL_NAME*`

Explicit name for the deployment.

This variable will be non-empty even if there is no assignment within the file.

| `*D_DPL_DESC*`

One-line description of the deployment.

| `*D_DPL_PRIORITY*`

Priority of the deployment (non-negative integer).

This variable will be non-empty even if there is no assignment within the file.

| `*D_DPL_FLAGS*`

One-character flags, causing special treatment.

| `*D_DPL_WARNING*`

One-line cautionary message about this deployment.

^.^h| Special directory paths

| [#var-dpl-dir]#`*D__DPL_DIR*`#

Absolute path to directory containing `*.dpl.sh` file.

| [#var-dpl-asset-dir]#`*D__DPL_ASSET_DIR*`#

Generated absolute path to directory assigned to hold assets of current deployment.

Located within <<grail-directory,the Grail>>, specifically `grail/assets/*_D_DPL_NAME_*/`.

| [#var-dpl-backup-dir]#`*D__DPL_BACKUP_DIR*`#

Generated absolute path to directory assigned to hold backups of current deployment.

Located within <<state-directory,state directory>>, specifically `state/backups/*_D_DPL_NAME_*/`.

^.^h| Special file paths

| [#var-dpl-sh-path]#`*D__DPL_SH_PATH*`#

Absolute path to `*.dpl.sh` file.

| [#var-dpl-mnf-path]#`*D__DPL_MNF_PATH*`#

Generated absolute path to asset manifest of current deployment.
This path does not necessarily exist.

Same as `*_D__DPL_SH_PATH_*`, but with suffix changed to `*.dpl.mnf`.

[.note]
[%noheader,cols="<.<a"]
!===
! Asset manifests are also processed by routines that don't source deployments.

Thus, path to asset manifest is locked, and this variable is read-only.
!===

| [#var-dpl-que-path]#`*D_DPL_QUE_PATH*`#

Generated absolute path to queue manifest of current deployment.
This path does not necessarily exist.

Same as `*_D__DPL_SH_PATH_*`, but with suffix changed to `*.dpl.que`.

[.note]
[%noheader,cols="<.<a"]
!===
! Queue manifests are processed only after sourcing their deployment file.

Thus, you are free to adjust this path at the top level of deployment script.
!===

^.^h| [#detected-os]#Detected operating system (OS)#

| [#var-os-family]#`*D__OS_FAMILY*`#

Broad description of current OS.

Exhaustive list of possible values:

* `bsd` — https://en.wikipedia.org/wiki/List_of_BSD_operating_systems[BSD descendants]
* `cygwin` — https://en.wikipedia.org/wiki/Cygwin[Cygwin]
* `linux` — https://en.wikipedia.org/wiki/Linux[Linux]
* `macos` — https://en.wikipedia.org/wiki/MacOS[macOS]
* `msys` — https://en.wikipedia.org/wiki/MinGW[Minimalist GNU for Windows]
* `solaris` — https://en.wikipedia.org/wiki/Solaris_(operating_system)[Oracle Solaris]
* `wsl` — https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux[Windows Subsystem for Linux]

[.note]
[%noheader,cols="<.<a"]
!===
! Note that `linux` and `wsl` are separate entries.
Check for both to determine whether currently under modern Linux, e.g.:

[source,bash,subs="verbatim,attributes"]
----
case $D__OS_FAMILY in
  linux{vbar}wsl)   echo linux;;
  *)           echo other;;
esac
----

!===

| [#var-os-distro]#`*D__OS_DISTRO*`#

Best guess on the name of the current OS distribution.

Exhaustive list of possible values:

* `debian`
* `fedora`
* `freebsd`
* `macos`
* `ubuntu`
* _empty_ — failed to reliably detect a supported distribution

[.note]
[%noheader,cols="<.<a"]
!===
! This list is incomplete; you can help by <<contributing-os-support,expanding it>>.
!===

| [#var-os-pkgmgr]#`*D__OS_PKGMGR*`#

Name of supported system package manager available on current system.

Exhaustive list of possible values:

* `apt-get`
* `brew`
* `dnf`
* `pkg`
* `yum`
* _empty_ — failed to reliably detect a supported package manager

[.note]
[%noheader,cols="<.<a"]
!===
! This list is incomplete; you can help by <<contributing-os-support,expanding it>>.
!===

When this variable is non-empty, you also have the built-in <<func-os-pkgmgr,package manager wrapper>>, `d__os_pkgmgr()`, at your disposal.

^.^h| [#marker-vars]#Marker variables in <<func-dpl-check,`d_dpl_check`>>#

| [#var-another-prompt]#`*D_DPL_NEEDS_ANOTHER_PROMPT*`#

Set this variable to `true` to trigger an <<urgent-prompt,urgent prompt>> before the framework proceeds to (un)installation.

_Works only during `install`/`remove` <<primary-routines,routine>> and only if set within <<func-dpl-check,`d_dpl_check`>> primary._

| [#var-another-warning]#`*D_DPL_NEEDS_ANOTHER_WARNING*`#

If `$D_DPL_NEEDS_ANOTHER_PROMPT` is set to `true` and this variable is non-empty, then its content is shown to the user as textual warning.

_Works only during `install`/`remove` <<primary-routines,routine>> and only if set within <<func-dpl-check,`d_dpl_check`>> primary._

| [#var-user-or-os]#`*D_DPL_INSTALLED_BY_USER_OR_OS*`#

Set this variable to `true` to signal to the framework: whatever parts of current deployment are installed, have been installed by other methods, not by this framework.

_Works only if set within `d_dpl_check()` primary._

This affects behavior of the following return codes of <<func-dpl-check,`d_dpl_check`>>:

* `1` ('installed') — prohibits uninstalling;
* `4` ('partly installed') — prohibits uninstalling.

[.note]
[%noheader,cols="<.<a"]
!===
! This is useful for deployments designed to not interfere with manual tinkering.
!===

^.^h| Parameters of current request

| `*D__REQ_ROUTINE*`

Name of <<primary-routines,primary routine>> currently being executed:

* `check`
* `install`
* `remove`

| `*D__OPT_FORCE*`

Whether `-f` / `--force` option is provided:

* `true`
* `false`

| [#var-opt-quiet]#`*D__OPT_QUIET*`#

Which verbosity options is provided last:

* `true` — quiet mode (or no verbosity options)
* `false` — verbose mode

| `*D__OPT_EXCLAM*`

Whether `-w` / `--with-!` option is provided to process <<dangerous-deployments,dangerous>> deployments:

* `true`
* `false`

| `*D__OPT_ANSWER*`

Which blanket answer is provided last.
This affects all non-<<urgent-prompt,urgent>> built-in prompts.

* `true` — affirmative answer is provided
* `false` — negatory answer is provided
* _empty_ — no blanket answer is provided

|===

=== Functions available to deployments

[[func-dprint]]
==== `dprint` family of functions

Functions named with prefix `dprint_` serve to unify styling and behavior of output across _Divine.dotfiles_.
They all print to `stderr`.

You are advised to serve all output of your deployments through one of these, in keeping with their semantics.

[source,subs="verbatim,quotes,attributes"]
----
*dprint_debug*    [-l] [-n] [*_CHUNK_*|-n|-i]...    {dhs} Debug message (appears 
                                              {hs}. only in --verbose mode)

*dprint_alert*         [-n] [*_CHUNK_*|-n|-i]...    {hs} Notable event/problem

*dprint_skip*          [-n] [*_CHUNK_*|-n|-i]...    {hs} Notable skip

*dprint_success*       [-n] [*_CHUNK_*|-n|-i]...    {hs} Notable success

*dprint_failure*       [-n] [*_CHUNK_*|-n|-i]...    {hs} Notable failure

*dprint_sudo*          [-n] [*_CHUNK_*|-n|-i]...    {dhs} Warning of upcoming sudo 
                                              {hs}. password prompt (appears only 
                                              {hs}. when caller currently does not
                                              {hs}. have sudo privelege)
----

.Example output of using a `dprint_*` function (coloring omitted)
[source,subs="verbatim,quotes,attributes"]
----
$ dprint_debug -l -n 'Extracting archive from:' -i "$archive_path" \
-n 'to your home directory'

*==>* Extracting archive from:
        /home/user/downloads/filename.tar.gz
    to your home directory
----

The `dprint` functions have the following *in common*:

* The output is prepended with a thematically styled 'fat' arrow: `=\=>`.
* All lines after the first are indented with four spaces.
* The output message is assembled from given ``*_CHUNK_*``s, which are just strings.
** Special `*_CHUNK_*`, `-n`, inserts a line break.
+
If `-n` is the very first chunk, line break appears before the introductory arrow.
** Special `*_CHUNK_*`, `-i`, inserts a line break followed by additional four-space indentation.
** In the produced message, normal chunks are separated with single space.
* Unrecognized options are treated as literal chunks.

The `dprint` functions *differ* in the following:

* `dprint_debug` honors current verbosity mode, as stored in <<var-opt-quiet,`$D__OPT_QUIET`>>.
+
All other `dprint` functions print their message regardless of verbosity.
To make `dprint_debug` the same way, add `-l` option as its very first argument.
* Entire message of `dprint_debug` is colored to stand out.
All other `dprint` functions print their message in terminal's font color.
* `dprint_sudo` prints its message only if calling context currently has no superuser priveleges.
Otherwise, nothing is printed.
* `dprint_sudo` is the only one that provides a default message if no chunks are given.
It reads:
+
`*=\=>* Sudo password is required`

The `dprint` functions carry following *semantics*:

[%header,cols="<.<1,<.<3",stripes=none]
|===

^.^| Function
^.^| Semantics

| `*dprint_debug*`
a| `[.blue]#*=\=>* Stage of internal logic#`

The intention is to quickly locate the point of failure, in case an error appears.
Only printed in verbose mode.

Put this everywhere: it won't show by default anyway.
| `*dprint_alert*`
a| `[.yellow]#*=\=>*# Notable non-fatal event/problem`

Sprinkle this sparingly, or it will likely be ignored.
| `*dprint_skip*`
a| `[.white]#*=\=>*# Notable non-fatal skipping of logic`

Use this if the skip is not problematic.
| `*dprint_success*`
a| `[.green]#*=\=>*# Notable success`

Avoid this unless the success is extraordinary.
| `*dprint_failure*`
a| `[.red]#*=\=>*# Notable failure, fatal or not`

Issue this on everything that is abnormal.
| `*dprint_sudo*`
a| `[.yellow]#*=\=>*# Warning of upcoming sudo password prompt`

Prepend this to your priveleged calls to inform user of why they need to enter their password.

|===

[.note]
[%noheader,cols="<.<a"]
|===
| Notice the word '_notable_' used throughout.
In general, it is *not* _notable_ when your deployment works as expected.
|===

[[func-dprompt]]
==== `dprompt` function

Function `dprompt` serves to unify styling and behavior of user prompts across _Divine.dotfiles_.
It prints to `stderr`.

You are advised to serve all user prompts of your deployments through this function.

[source,subs="verbatim,quotes,attributes"]
----
*dprompt* [-a *_ANSWER_*] [-p *_PROMPT_*] [-c *_COLOR_*] [-brkyq]... \
  [--] [-n] [*_CHUNKS_*|-n|-i]...
----

Interactively promts user for either:

* yes/no answer (default prompt message: `Proceed?`)
* any key press (default prompt message: `Press any key to continue`)

.Example output of using a `dprompt` function
[source,subs="verbatim,quotes,attributes"]
----
$ dprompt --prompt 'Are you sure?' --bare --or-quit -- -n 'Next step is risky!'

*==>* Next step is risky!
    Are you sure? [y/n/q]
----

Prints introductory message composed from ``*_CHUNK_*``s (these work the same as in `dprint` functions).
Then, prints the prompt message followed by declaration of expected response, e.g., `[y/n]`.

Returns:

* `0` on affirmative answer,
* `1` on negatory answer,
* `2` on special 'quit' answer (enabled by `--or-quit` option).

Below is the list of `dprompt` options.
Unrecognized options are silently ignored.

.List of `dprompt` options
[%noheader,cols="<.<a",stripes=none]
|===

| `*-a* *_ANSWER_*` `*--answer* *_ANSWER_*`

* If `*_ANSWER_*` is `true`, returns `0` immediately.
* If `*_ANSWER_*` is `false`, returns `1` immediately.
* Otherwise, proceeds with prompting.

[.note]
[%noheader,cols="<.<a"]
!===
! Call `dprompt --answer "$D__OPT_ANSWER"` to make the prompt honor `--yes`/`--no` options of the <<intervention-utility,intervention utility>>.
!===

| `*-p* *_PROMPT_*`, `*--prompt* *_PROMPT_*`

Customizes prompt text.
Limit this to a few words, e.g., `Are you sure?`.
Long-winded descriptions are better served in chunks as regular arguments.

| `*-c* *_COLOR_*`, `*--color* *_COLOR_*`

Uses one of the built-in colors in styling of the prompt: `$BLACK`, `$RED`, `$GREEN`, `$YELLOW` (_default_), `$BLUE`, `$MAGENTA`, `$CYAN`, `$WHITE`.

| `*-b*`

(_repeatable_) Gradually removes built-in coloring and bolding effects.
Depending on number of `-b` options, the following styling is used:

* 0:  bold, color, inverted color
* 1:  bold, color
* 2:  bold
* 3:  color
* 4+: _none_, synonym of `--bare`

| `*--bare*`

Completely removes built-in coloring and bolding from the prompt.
Synonym of `-bbbb`.

| `*-r*`, `*--arrow*`

Always prepend 'fat' arrow, `=\=>`, to the prompt.
Without this option, the arrow is only printed when there is at least one non-option argument.

| `*-k*`, `*--any-key*`

Special mode: return `0` on any key press after the prompt.

With this option `0` is immediately returned for both `true` and `false` values of `--answer` option.

| `*-y*`, `*--yes-no*`

Default mode: yes or no prompt.

| `*-q*`, `*--or-quit*`

In default mode, this option introduces the third option: `q` (stands for 'quit').
If user presses `q`, code `2` is returned by `dprompt`.

|===

[[func_dmd5]]
==== `dmd5` function

Function `dmd5` provides a cross-platform way of calculating an md5 checksum of a file or a string.

It relies on at least one of the following utilities being available in the system: `md5sum` or `md5` or `openssl`.

[source,subs="verbatim,quotes,attributes"]
----
*dmd5* [-s *_STRING_*] | [*_PATH_*]
----

* One checksum is calculated per call.
* Either a string or a path to a file may be given.
* It is up to you to ensure that path exists and is readable.
* Checksum is printed to `stdout`.

Returns zero on success and non-zero if something goes wrong.

==== `dstash` function

Function `dstash` is so important that it deserved its <<stash,own section>>.

[[func-os-pkgmgr]]
==== `d__os_pkgmgr` function

Function `d__os_pkgmgr` is a thin wrapper around system package manager.
The idea is to be able to install system packages without checking for current OS.
On OS's that are not yet supported, this function does nothing and returns non-zero.

[source,subs="verbatim,quotes,attributes"]
----
*d__os_pkgmgr* *update*|*check*|*install*|*remove* [*_PKG_NAME_*]
----

Launches one of the four routines, which are expected of any package manager out there.
Second argument (`*_PKG_NAME_*`), the name of single package, is relayed to the underlying package manager verbatim.
User prompts (except sudo password) are suppressed.

The first argument must be one of the four:

* `update` — updates all installed packages (other arguments are ignored).
* `check` — checks whether the provided package is installed.
Returns zero/non-zero appropriately.
* `install` — installs the provided package.
* `remove` — uninstalls the provided package.

[[stash]]
=== Stash

_Divine.dotfiles_ provides a persistent key-value storage and retrieval system.
It is based in file system, i.e., data is stored in files.
It is accessible within deployments via `dstash` function.

[source,subs="verbatim,quotes,attributes"]
----
*dstash* *ready*|*has*|*set*|*add*|*get*|*list*|*unset*|*clear* [-rgs] [ *_KEY_* [*_VALUE_*] ]
----

[#stash-types]#There are three levels of stashing system#:

* *Deployment stash* — exclusive to current deployment on current machine.
This is the default.
+
Stored in `state/stash/*_DPL-NAME_*/.stash.cfg`.
* *Root stash* — shared by all deployments on current machine.
+
Stored in `state/stash/.stash.cfg`.
* *Grail stash* — shared by all deployments across all machines that use the same <<grail-directory,Grail>>.
+
Stored in `grail/.stash.cfg`.

Rules of key-value store are:

* Keys must consist of: alphanumeric characters, underscore (`_`), and hyphen (`-`).
* Values must not exceed single line of text, but are otherwise unrestricted, and may be empty.
* Multiple instances of a key are allowed, values may be duplicate.

Depending on first argument, usage is as follows.

.Usage patterns of `dstash`
[%noheader,cols="<.<a",stripes=none]
|===

| `*ready*`

(_default task_) Checks that stashing system is primed and ready.

Returns `0` if stash is ready, or `2` if not.

| `*has* *_KEY_*`

Checks if stash contains at least one `*_KEY_*` with any value.

Returns `0` if so, or `1` otherwise.

| `*set* *_KEY_* [*_VALUE_*]`

Ensures presence of single `*_KEY_*` and sets it to `*_VALUE_*`.

Returns `0` on success, or `1` otherwise.

| `*add* *_KEY_* [*_VALUE_*]`

Adds one instance of `*_KEY_*` and sets it to `*_VALUE_*`.

Returns `0` on success, or `1` otherwise.

| `*get* *_KEY_*`

Prints the value of the first instance of `*_KEY_*` to `stdout`.

Returns `0` on success (even if nothing was printed), or `1` otherwise.

| `*list* *_KEY_*`

Prints each value of `*_KEY_*` on a line to `stdout`.

Returns `0` on success (even if nothing was printed), or `1` otherwise.

| `*unset* *_KEY_* [*_VALUE_*]`

If `*_VALUE_*` is provided: removes each instance of `*_KEY_*` containing that value.

Without `*_VALUE_*`: removes all instances of `*_KEY_*`.

Returns `0` on success (even if nothing was removed), or `1` otherwise.

| `*clear*`

Clears all records from this stash.

|===

Below is the list of `dstash` options.

.List of `dstash` options
[%noheader,cols="<.<a",stripes=none]
|===

| `*-s*`, `*--skip-checks*`

Normally, each invocation of `dstash` (with any arguments) starts with integrity check.
For repeated calls within a deployment, such checks become redundant.
After ensuring that `dstash ready`, use this option on every subsequent call to `dstash` to forego integrity checks.

| `*-r*`, `*--root*`

Works with <<stash-types,root stash>> instead of default deployment stash.

| `*-g*`, `*--grail*`

Works with <<stash-types,Grail stash>> instead of default deployment stash.

|===

[.note]
[%noheader,cols="<.<a"]
|===
| Records of attaching third-party bundles are stored in <<stash-types,Grail stash>>.

Records of installing optional framework dependencies are stored in <<stash-types,root stash>>.
|===

=== Manifests

_Divine.dotfiles_ introduces a simple markup language for special files called *manifests*.

There are three types of special files that are manifests:

* <<divinefiles, Divinefiles>>.
* <<asset-manifests, Asset manifests>>.
* <<queue-manifests, Queue manifests>>.

While they differ in purpose and supported features, all types of manifests share basic syntax, as they are internally parsed by the same engine.

[[manifest-syntax]]
==== Manifest syntax

Manifests are processed in terms of lines.
Simplest line contains an *entry* of some kind.

Whitespace rules are fairly permissive.
Any amount of leading and trailing whitespace is allowed and ignored.
Within an entry, whitespace is preserved.

[source]
----
entry1
entry2
entry with whitespace
  indented entry will not contain indentation
----

[[manifest-key-values]]
==== Manifest key-values

Whenever a line starts with an opening parenthesis `(` and contains a closing one `)`, what's between them is interpreted as a *key-value* pair.
Key-values are used to qualify entries and provide additional info.

A key-value is separated into key and value by the first occurrence of `:` (colon) within the parentheses.

There may be more than one key-value per line.
Key-values are recognized only when they occupy their own line or precede an entry.
Key-values that occupy their own line come into effect for the rest of the document, or until overridden.
Key-values that precede an entry affect only that entry.

[source,bash]
----
entry1                  # Regular entry
(color: red) entry2     # Set color to red for this entry only

(color: blue)           # Set color to blue henceforth

entry3                  # Color is blue
(color: green) entry4   # Color is green (overridden)
entry5                  # Color is blue

(color:)                # Unset color henceforth

entry6                  # Regular entry (no color)
entry7                  # Regular entry (no color)
----

[.note]
[%noheader,cols="<.<a"]
|===
| There are a few keys that are universal to all types of manifests.
They are described below.

Particular kinds of manifests support additional keys.
|===

==== OS-specific manifest entries

Key `os` makes entries specific to particular operating systems.
Multiple OS's may be given by separating with vartical bars.
Entire list of OS's may be negated (inverted) by prepending it with a `!`.

[source]
----
(os: debian)          entry1    # Relevant only on Debian

(os: macos|bsd)       entry2    # Relevant only on macOS or BSD

(os: ! linux | wsl)   entry3    # Relevant everywhere except Linux or WSL

(os: all)             entry4    ## Keywords 'all'/'any' are reserved to denote 
                                #. any OS. This is synonymous to empty list.
----

[.note]
[%noheader,cols="<.<a"]
|===
| OS names are matched against <<var-os-family,`$D\__OS_FAMILY`>> and <<var-os-distro,`$D__OS_DISTRO`>> built-in variables.
Single match against any of the two is sufficient.
|===

[[manifest-entry-flags]]
==== Manifest entry flags

Key `flags` adds a string of single-character flags to the entries.

Flags specifically have a *shorthand*: whenever a key-value does not contain a `:` (colon) separator (i.e., there is no key), content of parentheses is interpreted as `flags`.

Flags may be appended to those currently in effect, instead of replacing them, by including the plus sign '+' as the first non-whitespace char of the flags' value.

[source,bash]
----
(flags: i!0)  entry1    # Flags: i, !, 0

(flags: a)
              entry2    # Flags: a
(+b)
(flags: +c)   entry3    # Flags: a, b, c
              entry4    # Flags: a, b
(flags: d)    entry5    # Flags: d
              entry6    # Flags: a, b
----

==== Comments and line continuation in manifests

Hash/pound symbol (`#`) comments out the rest of the line.

A line may be 'glued' to the next by terminating it with a backslash (`\`).
Whitespace and comment are allowed to follow the backslash.

[source,bash]
----
(os: fedora)  \   ## This is a single logical line
lengthy entry \   #. spanning three physical lines
text              #. (yes, even with comments attached like this)
----

==== Escaping in manifests

* To start an entry with a literal opening parenthesis `(`, prepend it with a backslash `\`.
+
_One and only one backslash is always removed from the left edge of an entry._
* To use a literal closing parenthesis `)` within a key-value, prepend it with a backslash `\`.
* To use a literal hash/pound symbol `#` anywhere, prepend it with a backslash.
* To end a line with a literal backslash `\`, double every literal backslash at its right edge.
+
_Odd number of backslashes at the right edge will result in line continuation._

[[assets]]
=== Assets

If you intend to distribute your deployments, you will soon encounter the problem of separating more-or-less static deployment logic from dynamic deployment assets.

Lets study an example deployment that symlinks configuration files into the system.
It would be desirable to copy samples of those configuration files into user's <<grail-directory,Grail directory>>, and then create symlinks to the copies.
The user would then be free to inspect, modify, and synchronize his copies as his personal versions.
At the same time, the deployment logic is better kept within <<state-directory,state directory>>, where it would be easily updated by the framework.

Each deployment has a designated *asset directory*: `grail/assets/*_DPL-NAME_*/`, path to which is readable from a <<var-dpl-asset-dir,variable>>.
The asset directory is the space where user controls the behavior of the deployment by adding/modifying/removing asset files.
Deployments, on their part, are free to provide initial/default versions of some or all assets.

To facilitate handling of assets, _Divine.dotfiles_ offers the mechanism of *asset manifests*.

[[asset-manifests]]
==== Asset manifests

An *asset manifest* is a text file located in the same directory as the deployment file and named the same, except for exchanging `.dpl.sh` suffix for `.dpl.mnf`.
It serves two purposes:

* An asset manifest can ensure that a copy of every asset that you provide is placed into the deployment's <<var-dpl-asset-dir,asset directory>> inside the user's <<grail-directory,Grail>>, _unless_ an asset by that name already exists there.
* An asset manifest can automatically populate <<asset-arrays,global asset arrays>>, making the assets immediately available for processing by <<generic-queue,queues>> of <<link-queue,various>> <<copy-queue,kinds>>.

Entries in an asset manifest describe a set of *assets* (files and directories) by providing relative paths to them.
Relative paths are resolved from:

* <<var-dpl-dir,deployment directory>> (to locate initial versions provided by the author);
* <<var-dpl-asset-dir,asset directory>> (to locate user's versions to be processed by the framework).

[.note]
[%noheader,cols="<.<a"]
|===
| To reiterate, the framework never overwrites assets that are already present in asset directory.
|===

Processing of asset manifests occurs:

* During <<primary-routines,primary routines>>, immediately before sourcing the deployment file.
* During <<attach-routine,attaching of deployments>>, so that the assets of newly introduced deployments are immediately present in <<grail-directory,the Grail>>.

[[asset-manifest-syntax-and-behavior]]
==== Asset manifest syntax and behavior

Asset manifests follow the general <<manifest-syntax,manifest syntax>>.

Every entry is a *relative path*, which is resolved within <<var-dpl-dir,deployment>> and <<var-dpl-asset-dir,asset>> directories.
Two kinds of relative paths are accepted: *concrete paths* and *RegEx patterns*.
Leading and trailing slashes are disregarded in all paths in the asset manifests (including <<asset-manifest-prefix,`prefix`>> sub-paths).

The following <<manifest-entry-flags,*flags*>> are recognized within asset manifests for each asset entry:

.List of asset manifest entry flags
[%header,cols="<.<4,^.<1,<.<4",stripes=none]
|===

^.^| Behavior _without_ the flag (default)
^.^| Asset flag
^.^| Behavior _with_ the flag

| The entry is interpreted as a concrete path to a single asset.
| `*r*`

_**R**egEx_
| The entry is interpreted as a **R**egEx pattern (see <<asset-manifest-regex-note,note>> below), matching any number of assets.

| All matching files and directories within the <<var-dpl-dir,deployment directory>> are copied into the <<var-dpl-asset-dir,asset directory>>, unless the destination already exists.
Afterward, matching files and directories within the <<var-dpl-asset-dir,*asset directory*>> are pushed onto the <<asset-arrays,asset arrays>>.
| [#asset-flag-d]#`*d*`#

_**d**pl-dir-only_
| This asset entry does not leave the <<var-dpl-dir,**d**eployment directory>>.
Matching files and directories are not copied anywhere, and are pushed onto the <<asset-arrays,asset arrays>> from their original location.
This provides a way to conceal assets from user's view.

| Some version of the asset must be provided by the author into the <<var-dpl-dir,deployment directory>>.
(If the entry is a RegEx pattern, it must have at least one matching file/directory.)
Failing that, the entire deployment is not processed at all.
| `*o*`

_**o**ptional_
| The asset entry is considered **o**ptional: its provision by the author is not enforced.

| Files and directories matching the asset entry are pushed onto <<asset-arrays,asset arrays>> for further usage.
| `*n*`

_**n**o-queue_
| Files and directories matching the asset entry are **n**ot pushed onto <<asset-arrays,asset arrays>>.

_Together with the <<asset-flag-d,`d` flag>>, this will cause the asset to be completely ignored._

| All matching files and directories within the <<var-dpl-asset-dir,*asset directory*>> will be pushed onto <<asset-arrays,asset arrays>>.
This opens the door for user to add additional assets.

_Irrelevant when the <<asset-flag-d,`d` flag>> is in effect._
| `*p*`

_**p**rovided-only_
| The asset entry is considered limited to those matching files and directories, versions of which are **p**rovided by the author.

_Irrelevant when the <<asset-flag-d,`d` flag>> is in effect._

| Pre-existing files in the user's <<grail-directory,Grail>> are not overwritten under any circumstances.

| `*f*`

_**f**orce-copy_
| The framework ensures that a byte-by-byte copy of the provided version of an asset is present in the user's <<grail-directory,Grail>>.
If a differing version is found there, it is renamed by appending `-backup` suffix (with optional trailing ordinal for multiple backups), and the proper version is placed instead.
An alert is shown to the user whenever this happens.

*_Use this option sparingly!_*
The user is normally entitled to fully control their own Grail directory.
Replacing files there undermines the trust in your deployment.

This flag, however, is useful for supplying and updating READMEs.
In fact, whenever a file matching the RegEx pattern `README(\.[a-z]+)?` (case-sensitive) is replaced via this flag, the framework does not issue an alert or create a backup.
Naturally, this is designed for convenience, not security.

|===

The following <<manifest-key-values,*key-values*>> are recognized within asset manifests:

.Asset manifest key-values
[%noheader,cols="<.<a",stripes=none]
|===

| [#asset-manifest-prefix]#`(*prefix: _SUBPATH_*)`#

If you — the deployment author — want to contain your assets under some sub-path within the deployment directory, but you don't want that sub-path to be carried over to the asset directory, specify that sub-path in the `prefix` <<manifest-key-values,key>>.

| [#asset-manifest-queue-split]#`(*queue: split*)`#

This key-value does not work like the other key-values.
It does not affect the asset entries in any way.
Instead it creates a <<split-queue,queue split>> point wherever it appears.

|===

[#asset-manifest-regex-note]#Under the hood#, RegEx patterns are fed to the http://man7.org/linux/man-pages/man1/find.1.html[find] utility, using https://en.wikibooks.org/wiki/Regular_Expressions/POSIX-Extended_Regular_Expressions[POSIX Extended Regular Expressions] dialect.
The provided pattern is inserted into a larger one, similarly to the following example: `find -E . -regex "^\./${PATTERN}$"`.
As a consequence, the patterns should not include `^` and `$` meta-characters.

Order of entries in the asset manifest is guaranteed to correspond to the order of elements in the resulting <<asset-arrays,asset arrays>>.
However, order of files/directories matching a songle RegEx entry is not guaranteed.

Relative paths from a manifest are simply appended to their respective parent directory.
Paths like `.`, `..`, `../..`, etc. will work.
Keep in mind, tha asset manifests are designed for convenience, not security: with free-form Bash code within deployments, security is pretty much a moot point.

.Example of asset manifest
[source]
----
file1.txt           ## These files will be copied from deployment directory
file2.txt           #. into the root of asset directory.

(r) configs/\       ## Any .cfg files will be copied into 'configs/' directory. 
[a-z]+\.cfg         #. (Line continuation is part of manifest syntax.)

(prefix: images)
img1.jpg            ## These two files will be grabbed from 'images/' directory 
img2.jpg            #. and copied into the root of asset directory.
----

[[asset-arrays]]
==== Asset arrays

Whenever the framework processes an asset manifest, it automatically populates two global arrays:

* `*D_DPL_ASSET_PATHS*` — this array is filled with absolute paths to the assets within <<var-dpl-asset-dir,deployment's asset directory>> (contained in <<grail-directory,the Grail>>).
* `*D_QUEUE_MAIN*` — for each path in the previous array, this one will contain some relative version of that path at the same index.
Relative paths are resolved against <<var-dpl-asset-dir,deployment's asset directory>>.

You may notice, that these arrays coincide with those used in the <<generic-queue,queues>> (including <<link-queue,link>> and <<copy-queue,copy>> queue variations).
The reasoning there is that assets are perfect candidates to be handled by a queue.
You are, of course, free to override these automatically populated arrays.

[[generic-queue]]
=== Generic queue

Whenever your deployment performs a series of similar actions, — e.g., symlinks a bunch of files — you are faced with several routine tasks:

* Write iteration logic.
* Tie the return codes of subtasks into a single informative code.

_Divine.dotfiles_ offers a mechanism called *queue*, which relieves such pain.
To use it:

. Populate a specially named array with one string for each queue item.
. Implement logic to be applied to a single item.
. Delegate your deployment's <<primary-functions,primaries>> to built-in helpers.

This kind of deployment is best demonstrated with an example:

.Deployment template for generic queue
[source,bash]
----
# Delegate primaries to queue helpers. Make sure helper is called last.
d_dpl_check()    { populate_queue;  d__queue_check;    }
d_dpl_install()  {                  d__queue_install;  }
d_dpl_remove()   {                  d__queue_remove;   }

# This function is not built-in, but is the recommended way of organizing logic
populate_queue() { D_QUEUE_MAIN=( alpha bravo charlie ); }

# Implement mini-primaries for a single queue item
d_queue_item_check()    { :; }
d_queue_item_install()  { :; }
d_queue_item_remove()   { :; }
----

==== Generic queue set-up

Following Bash arrays should be populated before any of the built-in helpers are called:

.Variables required to set up generic queue
[%noheader,cols="<.<a",stripes=none]
|===

| [#var-queue-main]#`*D_QUEUE_MAIN*`#

Each member of this array defines a queue item.

Members of this array are simple strings.
In generic queues, the framework uses the strings themselves only for debug messages.

|===

The queue arrays must be consecutive.
Failing that, the queue will fail utterly and miserably.
You have been warned.

==== Generic queue hooks

Following built-in functions may be implemented to provide queue logic (all are optional).
The framework unsets every queue hook as soon as it is used up.

.Generic queue hooks
[%noheader,cols="<.<a",stripes=none]
|===

^.^h| Mini-primaries

| [#func-queue-item-check]#`*d_queue_item_check*`#

This function is called once for every queue item.
It is similar to its <<func-dpl-check,deployment-level cousin>>, `d_dpl_check`.

Supported return codes:

* `*0*` — *'Unknown'*: [.gray]##_(default)_## no reliable way to tell whether this queue item is installed or not.
* `*1*` — *'Installed'*: as it stands, intended goal of installing this queue item is entirely achieved.
* `*2*` — *'Not installed'*: as it stands, intended goal of installing this queue item is entirely not achieved.
* `*3*` — *'Invalid'*: input for this queue item prevents it from being processed correctly.

| [#func-queue-item-install]#`*d_queue_item_install*`#

This function is called no more than once for every queue item.
It is similar to its <<func-dpl-install,deployment-level cousin>>, `d_dpl_install`.

Supported return codes:

* `*0*` — *'Installed successfully'*: [.gray]##_(default)_## intended goal of installing this queue item is entirely achieved.
* `*1*` — *'Failed to install'*: intended goal of installing this deployment is not entirely achieved due to error.
* `*2*` — *'Item turned out to be invalid'*: input for this queue item prevents it from being installed correctly.
* `*3*` — *'Installed successfully'* and also abort further queue installation.
* `*4*` — *'Failed to install'* and also abort further queue installation.

| [#func-queue-item-remove]#`*d_queue_item_remove*`#

This function is called no more than once for every queue item.
It is similar to its <<func-dpl-remove,deployment-level cousin>>, `d_dpl_remove`.

Supported return codes:

* `*0*` — *'Uninstalled successfully'*: [.gray]##_(default)_## effects of previously installing this queue item are entirely reversed.
* `*1*` — *'Failed to uninstall'*: effects of previously installing this queue item are not entirely reversed due to error.
* `*2*` — *'Item turned out to be invalid'*: input for this queue item prevents it from being uninstalled correctly.
* `*3*` — *'Uninstalled successfully'* and also abort further queue uninstallation.
* `*4*` — *'Failed to uninstall'* and also abort further queue uninstallation.

^.^h| Other queue hooks

| `*d_queue_pre_check*`

This function is called once, before the queue is checked.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* `*_other_*` — *'Return this check code without checking'*

| `*d_queue_post_check*`

This function is called once, after the queue is entirelly checked.
Expect `$D{dus}QUEUE_RETURN_CODE` variable to be populated with the code that is currently set to be returned by the check primary.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* *_other_* — *'Return this check code instead'* _(combined check code of the queue is ignored)_

| `*d_queue_pre_install*`

This function is called once, before the queue is installed.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* `*_other_*` — *'Return this install code without installing'*

| `*d_queue_post_install*`

This function is called once, after the queue is entirelly installed.
Expect `$D{dus}QUEUE_RETURN_CODE` variable to be populated with the code that is currently set to be returned by the install primary.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* *_other_* — *'Return this install code instead'* _(combined install code of the queue is ignored)_

| `*d_queue_pre_remove*`

This function is called once, before the queue is removed.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* `*_other_*` — *'Return this remove code without removing'*

| `*d_queue_post_remove*`

This function is called once, after the queue is entirelly removed.
Expect `$D{dus}QUEUE_RETURN_CODE` variable to be populated with the code that is currently set to be returned by the remove primary.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* *_other_* — *'Return this remove code instead'* _(combined remove code of the queue is ignored)_

|===

==== Generic queue special variables

Following built-in variables are available/recognized during processing of each queue item:

.Generic queue special variables
[%noheader,cols="<.<a",stripes=none]
|===

| `*D{dus}QUEUE_ITEM_NUM*`

Index of current item in `*D_QUEUE_MAIN*`.
This index is helpful if you keep multiple arrays of related queue data.

| `*D{dus}QUEUE_ITEM_TITLE*`

Content of `*D_QUEUE_MAIN*` for current item.

| `*D{dus}QUEUE_ITEM_IS_FORCED*`

By default, the framework does *not*:

* re-install queue items that appear already installed;
* uninstall queue items that appear already not installed;
* process queue items that appear installed by means other than this framework.

The `--force` option of the intervention utility overrules such considerations.

This variable is set to `true` if installation/removal is being forced, i.e., it would not have been initiated if not for the `--force` option.
You are left to decide on whether to treat such cases specially.

| `*D{dus}QUEUE_ITEM_STASH_KEY*`

`*D{dus}QUEUE_ITEM_STASH_VALUE*`

`*D{dus}QUEUE_ITEM_STASH_FLAG*`

Stash key and stash value for current item.
The third variable is `true` if stash record exists, `false` if stash record does not exist, and not set if stash is not used for this item.

[.note]
[%noheader,cols="<.<a"]
!===
! Queue mechanism uses stash to keep persistent records of (un)installing queue items.
Ideally, there is no reason for you to know this or use these variables.
!===

| `*D{dus}QUEUE_RETURN_CODE*`

Within queue post-processing hooks, this variable is populated with the code that is set to be returned by the corresponding <<primary-functions,primary>>.
Changing this variable has no effect — use the hook's return code instead.

| `*D{dus}QUEUE_ITEM_RETURN_CODE*`

This variable is only relevant for <<link-queue,link>> and <<copy-queue,copy>> queue variations.
Within queue _item_ post-processing hooks, this variable is populated with the code that is set to be returned by the corresponding mini-primary.
Changing this variable has no effect — use the hook's return code instead.

|===

[[queue-manifests]]
==== Queue manifests

<<var-queue-main,Contents>> of the queue, whatever they are, sound like a perfect candidate for separation from deployment logic.
Queue manifests to the resqueue.

A *queue manifest* is a text file, which is — by default — located in the same directory as the deployment file and named the same, except for exchanging `.dpl.sh` suffix for `.dpl.que`.
Unlike with <<asset-manifests,asset manifests>>, you are free to customize the location/name of your queue manifest by re-assigning <<var-dpl-que-path,`D_DPL_QUE_PATH`>> variable *at the top level* of your deployment.

Queue manifests follow the general <<manifest-syntax,manifest syntax>>.
Only the key `os` is recognized within queue manifests.

[.note]
[%noheader,cols="<.<a"]
|===
| A suggested way of using queue manifests is:

. Provide a sample queue manifest of some entries in whatever form.
. Declare the queue manifest an asset, by listing it in your <<asset-manifests,asset manifest>>.
. Within the deployment, customize the <<var-dpl-que-path,`D_DPL_QUE_PATH`>> variable to point to asset copy within <<grail-directory,the Grail>>, e.g.:
+
[source,bash]
----
D_DPL_QUE_PATH="$D__DPL_ASSET_DIR/$D_DPL_NAME.dpl.que"
----
|===

[[link-queue]]
=== Link queue

A common use case of queues is creating symlinks that point to deployment's assets.
For example, one might want to:

* create symlinks located at `~/.bashrc` and `~/.zshrc`;
* point them at custom assets stored in <<grail-directory,the Grail>>;
* store original files as backups and restore them upon uninstallation.

For such purposes, _Divine.dotfiles_ provides a partially implemented version of <<generic-queue,generic queue>> called *link queue*.
To use it:

. Populate a few specially named arrays with necessary paths.
. Delegate your deployment's <<primary-functions,primaries>> to built-in helpers.

This kind of deployment is best demonstrated with an example:

.Deployment template for link queue
[source,bash]
----
# Delegate primaries to link queue helpers. Make sure helper is called last.
d_dpl_check()    { populate_link_queue; d__link_queue_check;    }
d_dpl_install()  {                      d__link_queue_install;  }
d_dpl_remove()   {                      d__link_queue_remove;   }

# This function is not built-in, but is the recommended way of organizing logic
populate_link_queue() {
  local src="$D__DPL_ASSET_DIR" dst=~
  D_QUEUE_MAIN=(            .bashrc        .zshrc )
  D_DPL_ASSET_PATHS=( "$src/.bashrc" "$src/.zshrc" )
  D_DPL_TARGET_PATHS=( $dst/.bashrc   $dst/.zshrc  )
}
----

==== Link queue set-up

Following Bash arrays should be populated before any of the built-in helpers are called.
Note, that you can <<link-queue-asset-automation,automate>> this process.

.Variables required to set up link queue
[%noheader,cols="<.<a",stripes=none]
|===

| `*D_QUEUE_MAIN*`

This variable is still the main definition of the queue.
In the context of link queue, for each absolute path in `*D_DPL_ASSET_PATHS*`, this array must contain a shortened relative version, resolvable from the asset directory.

| `*D_DPL_ASSET_PATHS*`

Each member of this array is an absolute path to which a symlink should be maintained.

| `*D_DPL_TARGET_PATHS*`

For each path in `*D_DPL_ASSET_PATHS*`, this array must contain the intended absolute path to a symlink, which will point to the respective asset.

|===

The queue arrays must be consecutive and have the same number of elements.
Failing that, the queue will fail utterly and miserably.
You have been warned.

==== Link queue hooks

Following built-in functions may be implemented to provide queue logic (all are optional).
The framework unsets every link queue hook as soon as it is used up.

.Link queue hooks
[%noheader,cols="<.<a",stripes=none]
|===

^.^h| Mini-primary hooks

| `*d_link_queue_item_pre_check*`

This function is called once, before the symlink is <<func-queue-item-check,checked>>.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* `*_other_*` — *'Return this item check code without checking'*

| `*d_link_queue_item_post_check*`

This function is called once, after the symlink is <<func-queue-item-check,checked>>.
Expect `$D{dus}QUEUE_ITEM_RETURN_CODE` variable to be populated with the code that is currently set to be returned by the check mini-primary.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* *_other_* — *'Return this item check code instead'* _(check code of the link queue item is ignored)_

| `*d_link_queue_item_pre_install*`

This function is called once, before the symlink is <<func-queue-item-install,installed>>.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* `*_other_*` — *'Return this item install code without installing'*

| `*d_link_queue_item_post_install*`

This function is called once, after the symlink is <<func-queue-item-install,installed>>.
Expect `$D{dus}QUEUE_ITEM_RETURN_CODE` variable to be populated with the code that is currently set to be returned by the install mini-primary.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* *_other_* — *'Return this item install code instead'* _(install code of the link queue item is ignored)_

| `*d_link_queue_item_pre_remove*`

This function is called once, before the symlink is <<func-queue-item-remove,uninstalled>>.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* `*_other_*` — *'Return this item remove code without removing'*

| `*d_link_queue_item_post_remove*`

This function is called once, after the symlink is <<func-queue-item-remove,uninstalled>>.
Expect `$D{dus}QUEUE_ITEM_RETURN_CODE` variable to be populated with the code that is currently set to be returned by the remove mini-primary.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* *_other_* — *'Return this item remove code instead'* _(remove code of the link queue item is ignored)_

^.^h| Overall queue hooks

| `*d_link_queue_pre_check*`

This function is called once, before the link queue is checked.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* `*_other_*` — *'Return this check code without checking'*

| `*d_link_queue_post_check*`

This function is called once, after the link queue is entirelly checked.
Expect `$D{dus}QUEUE_RETURN_CODE` variable to be populated with the code that is currently set to be returned by the check primary.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* *_other_* — *'Return this check code instead'* _(combined check code of the link queue is ignored)_

| `*d_link_queue_pre_install*`

This function is called once, before the link queue is installed.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* `*_other_*` — *'Return this install code without installing'*

| `*d_link_queue_post_install*`

This function is called once, after the link queue is entirelly installed.
Expect `$D{dus}QUEUE_RETURN_CODE` variable to be populated with the code that is currently set to be returned by the install primary.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* *_other_* — *'Return this install code instead'* _(combined install code of the link queue is ignored)_

| `*d_link_queue_pre_remove*`

This function is called once, before the link queue is removed.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* `*_other_*` — *'Return this remove code without removing'*

| `*d_link_queue_post_remove*`

This function is called once, after the link queue is entirelly removed.
Expect `$D{dus}QUEUE_RETURN_CODE` variable to be populated with the code that is currently set to be returned by the remove primary.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* *_other_* — *'Return this remove code instead'* _(combined remove code of the link queue is ignored)_

|===

[[link-queue-asset-automation]]
==== Link queue asset automation

So, you have your list of assets in a <<asset-manifests,manifest>>, and you know where to symlink them to.
Why bother with manually populating arrays?

No need.

_Divine.dotfiles_ provides two major automation avenues for link queue arrays:

* Arrays `*D_QUEUE_MAIN*` and `*D_DPL_ASSET_PATHS*` are both <<asset-arrays,automatically populated>> when the <<asset-manifests,asset manifest>> is processed, which happens immediately before your deployment file is sourced.
* Array `*D_DPL_TARGET_PATHS*` can be automatically populated if all your assets are intended to go into one target directory.
+
For that to occur, put the target directory into `*D_DPL_TARGET_DIR*` variable before any of the built-in helpers are called.
All your assets will be symlinked into the target directory, with relative paths preserved.
+
Keep in mind that this does rely on `*D_QUEUE_MAIN*` to contain relative paths, as is the requirement for link queues.

[[link-queue-cross-platform-overrides]]
==== Link queue cross-platform overrides

Cross-platformness, you say?
Your assets go into different target directories on different platforms?
No worries.

In _Divine.dotfiles_, every OS adapter carries an override mechanism for both `*D_DPL_TARGET_DIR*` and `*D_DPL_TARGET_PATHS*`.
The rules are simple: append the handle of the supported OS to the variable name in all capitals like this:

[source,bash]
----
D_DPL_TARGET_DIR=/generic/path
D_DPL_TARGET_DIR_MACOS=/path/on/macos
D_DPL_TARGET_DIR_FEDORA=/path/on/fedora
D_DPL_TARGET_DIR_WSL=/path/on/wsl
----

[.note]
[%noheader,cols="<.<a"]
|===
| The OS handles are matched against both  <<var-os-family,`$D\__OS_FAMILY`>> and <<var-os-distro,`$D__OS_DISTRO`>> built-in variables.
A match against distro overrules a match against family, because such is life.
|===

[[copy-queue]]
=== Copy queue

Another common use case of queues is copying files into the system.
For example, one might want to:

* copy an assortment of font files into the system's font directory;
* not overwrite existing files.

For such purposes, _Divine.dotfiles_ provides a partially implemented version of <<generic-queue,generic queue>> called *copy queue*.
To use it:

. Populate a few specially named arrays with necessary paths.
. Delegate your deployment's <<primary-functions,primaries>> to built-in helpers.

[.note]
[%noheader,cols="<.<a"]
|===
| Copy queue does not touch pre-existing files:

* If a file by that name already exists at destination — no copying is done.
* Upon uninstallation, a file is only erased if there is a record of it previously being copied into that location.

If you want to actually substitute existing files (while backing them up), prefer the <<link-queue,link queue>>.
|===

This kind of deployment is best demonstrated with an example:

.Deployment template for copy queue
[source,bash]
----
# Delegate primaries to copy queue helpers. Make sure helper is called last.
d_dpl_check()    { populate_copy_queue; d__copy_queue_check;    }
d_dpl_install()  {                      d__copy_queue_install;  }
d_dpl_remove()   {                      d__copy_queue_remove;   }

# This function is not built-in, but is the recommended way of organizing logic
populate_copy_queue() {
  local src="$D__DPL_ASSET_DIR" dst=/usr/share/fonts
  D_QUEUE_MAIN=(            font1.ttf        font2.ttf  )
  D_DPL_ASSET_PATHS=( "$src/font1.ttf" "$src/font2.ttf" )
  D_DPL_TARGET_PATHS=( $dst/font1.ttf   $dst/font2.ttf  )
}
----

==== Copy queue set-up

Following Bash arrays should be populated before any of the built-in helpers are called.
Note, that you can <<copy-queue-asset-automation,automate>> this process.

.Variables required to set up copy queue
[%noheader,cols="<.<a",stripes=none]
|===

| `*D_QUEUE_MAIN*`

This variable is still the main definition of the queue.
In the context of copy queue, for each absolute path in `*D_DPL_ASSET_PATHS*`, this array must contain a shortened relative version, resolvable from the asset directory.

| `*D_DPL_ASSET_PATHS*`

Each member of this array is an absolute path to file that is to be copied.

| `*D_DPL_TARGET_PATHS*`

For each path in `*D_DPL_ASSET_PATHS*`, this array must contain the destination absolute path for copying.

|===

The queue arrays must be consecutive and have the same number of elements.
Failing that, the queue will fail utterly and miserably.
You have been warned.

==== Copy queue hooks

Following built-in functions may be implemented to provide queue logic (all are optional).
The framework unsets every copy queue hook as soon as it is used up.

.Copy queue hooks
[%noheader,cols="<.<a",stripes=none]
|===

^.^h| Mini-primary hooks

| `*d_copy_queue_item_pre_check*`

This function is called once, before the copy is <<func-queue-item-check,checked>>.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* `*_other_*` — *'Return this item check code without checking'*

| `*d_copy_queue_item_post_check*`

This function is called once, after the copy is <<func-queue-item-check,checked>>.
Expect `$D{dus}QUEUE_ITEM_RETURN_CODE` variable to be populated with the code that is currently set to be returned by the check mini-primary.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* *_other_* — *'Return this check code instead'* _(check code of the copy queue item is ignored)_

| `*d_copy_queue_item_pre_install*`

This function is called once, before the copy is <<func-queue-item-install,installed>>.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* `*_other_*` — *'Return this item install code without installing'*

| `*d_copy_queue_item_post_install*`

This function is called once, after the copy is <<func-queue-item-install,installed>>.
Expect `$D{dus}QUEUE_ITEM_RETURN_CODE` variable to be populated with the code that is currently set to be returned by the install mini-primary.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* *_other_* — *'Return this install code instead'* _(install code of the copy queue item is ignored)_

| `*d_copy_queue_item_pre_remove*`

This function is called once, before the copy is <<func-queue-item-remove,uninstalled>>.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* `*_other_*` — *'Return this item remove code without removing'*

| `*d_copy_queue_item_post_remove*`

This function is called once, after the copy is <<func-queue-item-remove,uninstalled>>.
Expect `$D{dus}QUEUE_ITEM_RETURN_CODE` variable to be populated with the code that is currently set to be returned by the remove mini-primary.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* *_other_* — *'Return this remove code instead'* _(remove code of the copy queue item is ignored)_

^.^h| Overall queue hooks

| `*d_copy_queue_pre_check*`

This function is called once, before the copy queue is checked.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* `*_other_*` — *'Return this check code without checking'*

| `*d_copy_queue_post_check*`

This function is called once, after the copy queue is entirelly checked.
Expect `$D{dus}QUEUE_RETURN_CODE` variable to be populated with the code that is currently set to be returned by the check primary.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* *_other_* — *'Return this check code instead'* _(combined check code of the copy queue is ignored)_

| `*d_copy_queue_pre_install*`

This function is called once, before the copy queue is installed.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* `*_other_*` — *'Return this install code without installing'*

| `*d_copy_queue_post_install*`

This function is called once, after the copy queue is entirelly installed.
Expect `$D{dus}QUEUE_RETURN_CODE` variable to be populated with the code that is currently set to be returned by the install primary.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* *_other_* — *'Return this install code instead'* _(combined install code of the copy queue is ignored)_

| `*d_copy_queue_pre_remove*`

This function is called once, before the copy queue is removed.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* `*_other_*` — *'Return this remove code without removing'*

| `*d_copy_queue_post_remove*`

This function is called once, after the copy queue is entirelly removed.
Expect `$D{dus}QUEUE_RETURN_CODE` variable to be populated with the code that is currently set to be returned by the remove primary.
Supported return codes:

* `*0*` — *'Proceed as normal'*
* *_other_* — *'Return this remove code instead'* _(combined remove code of the copy queue is ignored)_

|===

[[copy-queue-asset-automation]]
==== Copy queue asset automation

So, you have your list of assets in a <<asset-manifests,manifest>>, and you know where to copy them to.
Why bother with manually populating arrays?

No need.

_Divine.dotfiles_ provides two major automation avenues for copy queue arrays:

* Arrays `*D_QUEUE_MAIN*` and `*D_DPL_ASSET_PATHS*` are both <<asset-arrays,automatically populated>> when the <<asset-manifests,asset manifest>> is processed, which happens immediately before your deployment file is sourced.
* Array `*D_DPL_TARGET_PATHS*` can be automatically populated if all your assets are intended to go into one target directory.
+
For that to occur, put the target directory into `*D_DPL_TARGET_DIR*` variable before any of the built-in helpers are called.
All your assets will be copied into the target directory, with relative paths preserved.
+
Keep in mind that this does rely on `*D_QUEUE_MAIN*` to contain relative paths, as is the requirement for copy queues.

[[copy-queue-cross-platform-overrides]]
==== Copy queue cross-platform overrides

Cross-platformness, you say?
Your assets go into different target directories on different platforms?
No worries.

In _Divine.dotfiles_, every OS adapter carries an override mechanism for both `*D_DPL_TARGET_DIR*` and `*D_DPL_TARGET_PATHS*`.
The rules are simple: append the handle of the supported OS to the variable name in all capitals like this:

[source,bash]
----
D_DPL_TARGET_DIR=/generic/path
D_DPL_TARGET_DIR_MACOS=/path/on/macos
D_DPL_TARGET_DIR_FEDORA=/path/on/fedora
D_DPL_TARGET_DIR_WSL=/path/on/wsl
----

[.note]
[%noheader,cols="<.<a"]
|===
| The OS handles are matched against both  <<var-os-family,`$D\__OS_FAMILY`>> and <<var-os-distro,`$D__OS_DISTRO`>> built-in variables.
A match against distro overrules a match against family, because such is life.
|===

[[multitask]]
=== Multitask

What if a deployment carries out an assortment of _dissimilar_ tasks?
Tying up various return codes to integrate with _Divine.dotfiles_ would be tedious.

*Multitask* helpers will take up that task.
To use them:

. Populate a specially named array with one string for each task.
. Implement sub-primaries for the tasks, as if each one was a deployment of its own.
. Delegate your deployment's <<primary-functions,primaries>> to built-in helpers.

This kind of deployment is best demonstrated with an example:

.Deployment template for multitasking
[source,bash]
----
# Delegate primaries to multitask helpers. Make sure helper is called last.
d_dpl_check()    { assemble_tasks;  d__multitask_check;   }
d_dpl_install()  {                  d__multitask_install; }
d_dpl_remove()   {                  d__multitask_remove;  }

# This function is not built-in, but is the recommended way of organizing logic
assemble_tasks() {  D_MULTITASK_NAMES=( eat pray love );  }

# Implement sub-primaries for each task, following guidelines for primaries

d_eat_check()     { :; }
d_eat_install()   { :; }
d_eat_remove()    { :; }

d_pray_check()    { :; }
d_pray_install()  { :; }
d_pray_remove()   { :; }

d_love_check()    { :; }
d_love_install()  { :; }
d_love_remove()   { :; }
----

==== Multitask set-up

Following Bash arrays should be populated before any of the built-in helpers are called:

.Variables required to set up multitask deployment
[%noheader,cols="<.<a",stripes=none]
|===

| [#var-multitask-names]#`*D_MULTITASK_NAMES*`#

Each member of this array defines a task.

Members of this array are strings, and are used in forming names of sub-primaries, which you then have to implement:

[source,subs="verbatim,quotes,attributes"]
----
          d{us}**__TASK__**{us}check
*_TASK_*  =>  d{us}**__TASK__**{us}install
          d{us}**__TASK__**{us}remove
----

|===

The multitask array must be consecutive.
Failing that, the deployment will fail utterly and miserably.
You have been warned.

==== Multitask hooks

Following built-in functions may be implemented to provide task logic (all are optional):

.Multitask hooks
[%noheader,cols="<.<a",stripes=none]
|===

^.^h| Sub-primaries

| [#func-task-check]#`*d{us}__TASK__{us}check*`#

See the guidelines to the <<func-dpl-check,deployment-level sibling>>, `d_dpl_check`.

| [#func-task-install]#`*d{us}__TASK__{us}install*`#

See the guidelines to the <<func-dpl-install,deployment-level sibling>>, `d_dpl_install`.

| [#func-task-remove]#`*d{us}__TASK__{us}remove*`#

See the guidelines to the <<func-dpl-remove,deployment-level sibling>>, `d_dpl_remove`.

|===

[[split-queue]]
==== Split queue

Eventually, you will want to include more than one queue in your multitask deployment.
And therein lies a _gotcha_.

All queues share the same internal mechanism.
Care must be taken to employ this mechanism multiple times within single deployment.
Specifically, the queue must be *split* by calling internal function `*d__queue_split*`.

This is best illustrated with an example:

.Deployment template for multitasking with split queue
[source,bash,subs="verbatim,quotes,attributes"]
----
# Delegate primaries to multitask helpers. Make sure helper is called last.
d_dpl_check()    { assemble_tasks;  d{dus}multitask_check;   }
d_dpl_install()  {                  d{dus}multitask_install; }
d_dpl_remove()   {                  d{dus}multitask_remove;  }

# This function is not built-in, but is the recommended way of organizing logic
assemble_tasks() {  D_MULTITASK_NAMES=( queue1 queue2 queue3 ); }

# In this case all three tasks contain a queue

d_queue1_check()    { populate_copy_queue;    d{dus}copy_queue_check;    }
d_queue1_install()  {                         d{dus}copy_queue_install;  }
d_queue1_remove()   {                         d{dus}copy_queue_remove;   }

d_queue2_check()    { populate_link_queue;    d{dus}link_queue_check;    }
d_queue2_install()  {                         d{dus}link_queue_install;  }
d_queue2_remove()   {                         d{dus}link_queue_remove;   }

d_queue3_check()    { populate_generic_queue; d{dus}queue_check;         }
d_queue3_install()  {                         d{dus}queue_install;       }
d_queue3_remove()   {                         d{dus}queue_remove;        }


populate_copy_queue() {
  # Populate the first queue normally (arrays specific to copy queue omitted)
  D_QUEUE_MAIN=( some copy tasks )
}

populate_link_queue() {
  # In subsequent queues, call this built-in function first
  d{dus}queue_split

  # Then {as}append{as} to the queue array (arrays specific to link queue omitted)
  D_QUEUE_MAIN+=( add link jobs )
}

populate_generic_queue() {
  d{dus}queue_split

  D_QUEUE_MAIN+=( generic queue work )
}
----

[.note]
[%noheader,cols="<.<a"]
|===
| If you use <<asset-manifests,asset manifests>>, you may <<asset-manifest-queue-split,split your queue>> directly within the asset manifest file.
|===

== Ways to contribute

You are free to contribute to _Divine.dotfiles_ in any way you deem beneficial.
This section is periodically updated to state the most sought after avenues of improvement.

[[contributing-os-support]]
=== Contributing OS support

One of the main goals of this framework is *portability*.

In _Divine.dotfiles_, the code that supports particular operating systems is isolated within special files called *adapters*.
An OS distribution adapter allows the framework to interact with that OS and with its built-in package manager.

* An adapter is a Bash script with special functions implemented.
* Adapter template and guidelines are located in `lib/templates/adapters/distro.adp.sh`.
* Active adapters are put into `lib/adapters/distro/`.

Adapters for all OS distributions out there will be welcomed with open arms.

== Divine deployments

Divine deployments are deployments developed and distributed along with _Divine.dotfiles_.
Apart from being useful by themselves, they serve as an illustration of the framework's mechanisms put to good use.

.List of Divine deployments
[%noheader,cols="<.<a",stripes=none]
|===

| https://github.com/no-simpler/divine-bundle-essentials[Essentials] _(fully functional and documented)_

A bundle of core deployments, mostly centered around 'classic' dotfiles.

| https://github.com/no-simpler/divine-bundle-gpg-primer[GnuPG best practices] _(fully functional on macOS, not yet fully documented)_

Automates adherence to best security practices in regards to https://www.gnupg.org[GnuPG].

| https://github.com/no-simpler/divine-bundle-ssh-primer[SSH key handling] _(fully functional on macOS, not yet fully documented)_

Automates secure stashing and retrieval of SSH secret keys.

| https://github.com/no-simpler/divine-bundle-fonts[Fonts collection] _(fully functional on macOS & Ubuntu, not yet fully documented)_

Maintains a collection of personal font files across machines.

^.^h| macOS-specific deployments

| https://github.com/no-simpler/divine-bundle-macos-local-server[Local development server] _(fully functional on macOS, not yet fully documented)_

Maintains a local development server on macOS.
For the most part, it automates instructions from https://getgrav.org/blog/macos-mojave-apache-multiple-php-versions[this article].

| https://github.com/no-simpler/divine-bundle-macos-tilde-switch[Tilde-switch] _(fully functional on macOS, not yet fully documented)_

Programmatically switches keys tilde `~` and plus-minus `±` on a MacBook’s built-in physical keyboard.

^.^h| App-specific configuration deployments

| https://github.com/no-simpler/divine-bundle-config-vscode[Visual Studio Code] _(fully functional on macOS, not yet fully documented)_

Maintains configuration for https://code.visualstudio.com[VS Code].

| https://github.com/no-simpler/divine-bundle-config-hyperjs[Hyper.js] _(fully functional on macOS, not yet fully documented)_

Maintains configuration for https://hyper.is[Hyper] terminal.

| https://github.com/no-simpler/divine-bundle-config-transmissionbt[Transmission BT] _(fully functional on macOS, not yet fully documented)_

Maintains configuration for https://transmissionbt.com[Transmission].

|===